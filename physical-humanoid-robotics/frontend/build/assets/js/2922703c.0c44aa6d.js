"use strict";(globalThis.webpackChunkphysical_humanoid_robotics_book=globalThis.webpackChunkphysical_humanoid_robotics_book||[]).push([[247],{8453(n,e,i){i.d(e,{R:()=>a,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function a(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),t.createElement(o.Provider,{value:e},n.children)}},9574(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"modules/module-2/module-2-chapter-5","title":"Digital Twin Integration with ROS 2","description":"This chapter explores how to integrate digital twin systems with ROS 2, creating a seamless connection between simulation and real-world robotics applications.","source":"@site/content/modules/module-2/chapter-5.md","sourceDirName":"modules/module-2","slug":"/modules/module-2/module-2-chapter-5","permalink":"/docs/modules/module-2/module-2-chapter-5","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-humanoid-robotics/physical-humanoid-robotics-book/tree/main/packages/create-docusaurus/templates/shared/content/modules/module-2/chapter-5.md","tags":[],"version":"current","frontMatter":{"id":"module-2-chapter-5","title":"Digital Twin Integration with ROS 2","sidebar_label":"Digital Twin Integration"},"sidebar":"tutorialSidebar","previous":{"title":"Sim-to-Real Transfer","permalink":"/docs/modules/module-2/module-2-chapter-4"},"next":{"title":"Isaac AI Basics","permalink":"/docs/modules/module-3/module-3-chapter-1"}}');var s=i(4848),o=i(8453);const a={id:"module-2-chapter-5",title:"Digital Twin Integration with ROS 2",sidebar_label:"Digital Twin Integration"},r="Digital Twin Integration with ROS 2",l={},m=[{value:"Architecture for Digital Twin Integration",id:"architecture-for-digital-twin-integration",level:2},{value:"ROS 2 Bridge Implementation",id:"ros-2-bridge-implementation",level:2},{value:"Advanced Synchronization Techniques",id:"advanced-synchronization-techniques",level:2},{value:"Time Synchronization",id:"time-synchronization",level:3},{value:"Data Buffering for Smooth Synchronization",id:"data-buffering-for-smooth-synchronization",level:3},{value:"Visualization and Monitoring",id:"visualization-and-monitoring",level:2},{value:"Unity Integration with ROS 2",id:"unity-integration-with-ros-2",level:2},{value:"Exercise: Implement a Digital Twin Bridge",id:"exercise-implement-a-digital-twin-bridge",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"digital-twin-integration-with-ros-2",children:"Digital Twin Integration with ROS 2"})}),"\n",(0,s.jsx)(e.p,{children:"This chapter explores how to integrate digital twin systems with ROS 2, creating a seamless connection between simulation and real-world robotics applications."}),"\n",(0,s.jsx)(e.h2,{id:"architecture-for-digital-twin-integration",children:"Architecture for Digital Twin Integration"}),"\n",(0,s.jsx)(e.p,{children:"The integration architecture typically follows this pattern:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Real Robot \u2190\u2192 ROS 2 Bridge \u2190\u2192 Digital Twin \u2190\u2192 Analysis Tools\n    \u2191              \u2191                \u2191            \u2191\nHardware I/O \u2190\u2192 Message Bus \u2190\u2192 Simulation \u2190\u2192 Visualization\n"})}),"\n",(0,s.jsx)(e.h2,{id:"ros-2-bridge-implementation",children:"ROS 2 Bridge Implementation"}),"\n",(0,s.jsx)(e.p,{children:"Creating a bridge between real robot and digital twin:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu, Image\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Bool\nimport numpy as np\nimport time\n\nclass DigitalTwinBridge(Node):\n    def __init__(self):\n        super().__init__(\'digital_twin_bridge\')\n\n        # Real robot interfaces\n        self.real_joint_sub = self.create_subscription(\n            JointState, \'/real/joint_states\', self.real_joint_callback, 10\n        )\n        self.real_imu_sub = self.create_subscription(\n            Imu, \'/real/imu/data\', self.real_imu_callback, 10\n        )\n        self.real_cmd_pub = self.create_publisher(\n            JointState, \'/real/joint_commands\', 10\n        )\n\n        # Digital twin interfaces\n        self.sim_joint_pub = self.create_publisher(\n            JointState, \'/sim/joint_states\', 10\n        )\n        self.sim_imu_pub = self.create_publisher(\n            Imu, \'/sim/imu/data\', 10\n        )\n        self.sim_cmd_sub = self.create_subscription(\n            JointState, \'/sim/joint_commands\', self.sim_cmd_callback, 10\n        )\n\n        # Synchronization timer\n        self.bridge_timer = self.create_timer(0.01, self.synchronization_callback)  # 100Hz\n\n        # Data buffers\n        self.real_joint_state = None\n        self.sim_joint_state = None\n        self.synchronization_enabled = True\n\n    def real_joint_callback(self, msg):\n        """Process joint states from real robot"""\n        self.real_joint_state = msg\n        if self.synchronization_enabled:\n            # Publish to digital twin\n            self.sim_joint_pub.publish(msg)\n\n    def real_imu_callback(self, msg):\n        """Process IMU data from real robot"""\n        if self.synchronization_enabled:\n            # Publish to digital twin with possible noise addition\n            noisy_imu = self.add_simulation_noise(msg)\n            self.sim_imu_pub.publish(noisy_imu)\n\n    def sim_cmd_callback(self, msg):\n        """Process commands from digital twin and send to real robot"""\n        if self.synchronization_enabled:\n            # Apply safety checks before sending to real robot\n            safe_cmd = self.apply_safety_filters(msg)\n            self.real_cmd_pub.publish(safe_cmd)\n\n    def add_simulation_noise(self, imu_msg):\n        """Add realistic noise to IMU data for simulation"""\n        noisy_imu = Imu()\n        noisy_imu.header = imu_msg.header\n\n        # Add noise to angular velocity\n        noisy_imu.angular_velocity.x = imu_msg.angular_velocity.x + np.random.normal(0, 0.01)\n        noisy_imu.angular_velocity.y = imu_msg.angular_velocity.y + np.random.normal(0, 0.01)\n        noisy_imu.angular_velocity.z = imu_msg.angular_velocity.z + np.random.normal(0, 0.01)\n\n        # Add noise to linear acceleration\n        noisy_imu.linear_acceleration.x = imu_msg.linear_acceleration.x + np.random.normal(0, 0.05)\n        noisy_imu.linear_acceleration.y = imu_msg.linear_acceleration.y + np.random.normal(0, 0.05)\n        noisy_imu.linear_acceleration.z = imu_msg.linear_acceleration.z + np.random.normal(0, 0.05)\n\n        return noisy_imu\n\n    def apply_safety_filters(self, cmd_msg):\n        """Apply safety filters to commands before sending to real robot"""\n        filtered_cmd = JointState()\n        filtered_cmd.header = cmd_msg.header\n        filtered_cmd.name = cmd_msg.name\n        filtered_cmd.position = []\n\n        for pos in cmd_msg.position:\n            # Apply position limits\n            filtered_pos = max(min(pos, 3.14), -3.14)  # \xb1\u03c0 rad limits\n            filtered_cmd.position.append(filtered_pos)\n\n        return filtered_cmd\n\n    def synchronization_callback(self):\n        """Synchronize data between real robot and digital twin"""\n        # This method can implement more complex synchronization logic\n        # such as time alignment, data buffering, etc.\n        pass\n'})}),"\n",(0,s.jsx)(e.h2,{id:"advanced-synchronization-techniques",children:"Advanced Synchronization Techniques"}),"\n",(0,s.jsx)(e.h3,{id:"time-synchronization",children:"Time Synchronization"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class TimeSynchronizer:\n    def __init__(self):\n        self.real_time_offset = 0.0\n        self.sim_time_offset = 0.0\n        self.time_sync_enabled = True\n\n    def synchronize_timestamps(self, real_msg, sim_msg):\n        """Align timestamps between real and simulated systems"""\n        if self.time_sync_enabled:\n            # Adjust simulation time to match real time\n            sim_msg.header.stamp = real_msg.header.stamp\n        return real_msg, sim_msg\n'})}),"\n",(0,s.jsx)(e.h3,{id:"data-buffering-for-smooth-synchronization",children:"Data Buffering for Smooth Synchronization"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"from collections import deque\nimport threading\n\nclass DataBuffer:\n    def __init__(self, buffer_size=100):\n        self.buffer = deque(maxlen=buffer_size)\n        self.lock = threading.Lock()\n\n    def add_data(self, data):\n        with self.lock:\n            self.buffer.append(data)\n\n    def get_recent_data(self, n=1):\n        with self.lock:\n            if len(self.buffer) >= n:\n                return list(self.buffer)[-n:]\n            else:\n                return list(self.buffer)\n"})}),"\n",(0,s.jsx)(e.h2,{id:"visualization-and-monitoring",children:"Visualization and Monitoring"}),"\n",(0,s.jsx)(e.p,{children:"Creating a monitoring interface for the digital twin:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport numpy as np\n\nclass DigitalTwinMonitor:\n    def __init__(self):\n        self.fig, self.axs = plt.subplots(2, 2, figsize=(12, 8))\n        self.real_joint_positions = []\n        self.sim_joint_positions = []\n        self.errors = []\n\n        # Setup plots\n        self.setup_plots()\n\n    def setup_plots(self):\n        """Setup matplotlib plots for monitoring"""\n        self.axs[0, 0].set_title(\'Real Robot Joint Positions\')\n        self.axs[0, 1].set_title(\'Simulated Robot Joint Positions\')\n        self.axs[1, 0].set_title(\'Position Errors\')\n        self.axs[1, 1].set_title(\'Synchronization Status\')\n\n    def update_plots(self, real_pos, sim_pos):\n        """Update plots with new data"""\n        self.real_joint_positions.append(real_pos)\n        self.sim_joint_positions.append(sim_pos)\n\n        # Calculate errors\n        if len(real_pos) == len(sim_pos):\n            error = [abs(r - s) for r, s in zip(real_pos, sim_pos)]\n            self.errors.append(error)\n\n        # Update each subplot\n        self.axs[0, 0].clear()\n        self.axs[0, 0].plot(real_pos)\n        self.axs[0, 0].set_title(\'Real Robot Joint Positions\')\n\n        self.axs[0, 1].clear()\n        self.axs[0, 1].plot(sim_pos)\n        self.axs[0, 1].set_title(\'Simulated Robot Joint Positions\')\n\n        self.axs[1, 0].clear()\n        if self.errors:\n            self.axs[1, 0].plot(self.errors[-50:])  # Show last 50 errors\n        self.axs[1, 0].set_title(\'Position Errors\')\n\n        self.axs[1, 1].clear()\n        sync_status = "Active" if self.is_synchronized() else "Drift Detected"\n        self.axs[1, 1].text(0.5, 0.5, sync_status, ha=\'center\', va=\'center\',\n                           transform=self.axs[1, 1].transAxes, fontsize=14)\n        self.axs[1, 1].set_title(\'Synchronization Status\')\n\n        plt.tight_layout()\n\n    def is_synchronized(self):\n        """Check if real and sim are synchronized"""\n        if not self.errors:\n            return True\n        avg_error = np.mean(self.errors[-10:]) if len(self.errors) >= 10 else 0\n        return avg_error < 0.1  # Threshold for synchronization\n'})}),"\n",(0,s.jsx)(e.h2,{id:"unity-integration-with-ros-2",children:"Unity Integration with ROS 2"}),"\n",(0,s.jsx)(e.p,{children:"For Unity-based digital twins, creating a ROS 2 bridge:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-csharp",children:'using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Sensor;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Geometry;\n\npublic class UnityROSBridge : MonoBehaviour\n{\n    ROSConnection ros;\n    public string rosIP = "127.0.0.1";\n    public int rosPort = 10000;\n\n    // Robot model references\n    public Transform[] jointTransforms;\n    public string[] jointNames;\n\n    void Start()\n    {\n        ros = ROSConnection.GetOrCreateInstance();\n        ros.Initialize(rosIP, rosPort);\n\n        // Subscribe to ROS topics\n        ros.Subscribe<JointStateMsg>("/real/joint_states", JointStateCallback);\n\n        // Start publishing simulated data\n        InvokeRepeating("PublishSimData", 0.0f, 0.05f);\n    }\n\n    void JointStateCallback(JointStateMsg jointState)\n    {\n        // Update Unity robot model based on real robot joint states\n        for (int i = 0; i < jointNames.Length; i++)\n        {\n            int jointIndex = System.Array.IndexOf(jointState.name, jointNames[i]);\n            if (jointIndex >= 0 && jointIndex < jointState.position.Length)\n            {\n                UpdateJoint(jointTransforms[i], jointState.position[jointIndex]);\n            }\n        }\n    }\n\n    void UpdateJoint(Transform joint, float angle)\n    {\n        // Apply rotation to joint (adjust based on joint type)\n        joint.localRotation = Quaternion.Euler(0, angle * Mathf.Rad2Deg, 0);\n    }\n\n    void PublishSimData()\n    {\n        // Publish simulated sensor data\n        var imuMsg = new ImuMsg();\n        imuMsg.header.stamp = new builtin_interfaces.msg.Time();\n        // Fill in IMU data from Unity physics\n        ros.Publish("/sim/imu/data", imuMsg);\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-implement-a-digital-twin-bridge",children:"Exercise: Implement a Digital Twin Bridge"}),"\n",(0,s.jsx)(e.p,{children:"Create a complete digital twin bridge that:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Receives joint states from a real robot"}),"\n",(0,s.jsx)(e.li,{children:"Updates a simulation model in real-time"}),"\n",(0,s.jsx)(e.li,{children:"Implements safety filters for commands"}),"\n",(0,s.jsx)(e.li,{children:"Provides synchronization monitoring"}),"\n",(0,s.jsx)(e.li,{children:"Visualizes the comparison between real and simulated states"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"Digital twin integration with ROS 2 enables powerful development and testing capabilities for robotic systems. By creating robust bridges between real and simulated systems, we can leverage the benefits of both environments while maintaining safety and synchronization. This approach is particularly valuable for humanoid robots where development time and safety are critical factors."}),"\n",(0,s.jsx)(e.hr,{})]})}function c(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);