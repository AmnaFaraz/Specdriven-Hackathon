"use strict";(globalThis.webpackChunkphysical_humanoid_robotics_book=globalThis.webpackChunkphysical_humanoid_robotics_book||[]).push([[295],{729(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"modules/module-5/module-5-chapter-2","title":"Humanoid Robot Control Systems","description":"This chapter delves into the control systems that enable precise and stable movement of the humanoid robot, including whole-body control, balance maintenance, and coordinated motion planning.","source":"@site/content/modules/module-5/chapter-2.md","sourceDirName":"modules/module-5","slug":"/modules/module-5/module-5-chapter-2","permalink":"/docs/modules/module-5/module-5-chapter-2","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-humanoid-robotics/physical-humanoid-robotics-book/tree/main/packages/create-docusaurus/templates/shared/content/modules/module-5/chapter-2.md","tags":[],"version":"current","frontMatter":{"id":"module-5-chapter-2","title":"Humanoid Robot Control Systems","sidebar_label":"Control Systems"},"sidebar":"tutorialSidebar","previous":{"title":"Project Overview","permalink":"/docs/modules/module-5/module-5-chapter-1"},"next":{"title":"AI Perception","permalink":"/docs/modules/module-5/module-5-chapter-3"}}');var s=t(4848),r=t(8453);const a={id:"module-5-chapter-2",title:"Humanoid Robot Control Systems",sidebar_label:"Control Systems"},i="Humanoid Robot Control Systems",l={},c=[{value:"Control Architecture",id:"control-architecture",level:2},{value:"Whole-Body Control Framework",id:"whole-body-control-framework",level:2},{value:"Inverse Kinematics Solver",id:"inverse-kinematics-solver",level:3},{value:"Whole-Body Controller",id:"whole-body-controller",level:3},{value:"Balance Control Systems",id:"balance-control-systems",level:2},{value:"Center of Mass (CoM) Control",id:"center-of-mass-com-control",level:3},{value:"Walking Control Systems",id:"walking-control-systems",level:2},{value:"Walking Pattern Generator",id:"walking-pattern-generator",level:3},{value:"Control Integration",id:"control-integration",level:2},{value:"Integrated Control System",id:"integrated-control-system",level:3},{value:"Exercise: Implement Control System",id:"exercise-implement-control-system",level:2},{value:"Summary",id:"summary",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"humanoid-robot-control-systems",children:"Humanoid Robot Control Systems"})}),"\n",(0,s.jsx)(n.p,{children:"This chapter delves into the control systems that enable precise and stable movement of the humanoid robot, including whole-body control, balance maintenance, and coordinated motion planning."}),"\n",(0,s.jsx)(n.h2,{id:"control-architecture",children:"Control Architecture"}),"\n",(0,s.jsx)(n.p,{children:"The humanoid robot employs a hierarchical control architecture with multiple layers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Control Architecture                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Behavior Layer                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  High-Level Behaviors: Walking, Standing, Grasping, etc.    \u2502 \u2502\n\u2502  \u2502  Task Planning and Sequencing                               \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                 \u2502\n\u2502  Motion Planning Layer                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  Trajectory Generation: Joint Space, Cartesian Space       \u2502 \u2502\n\u2502  \u2502  Inverse Kinematics, Dynamic Walking Patterns               \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                 \u2502\n\u2502  Feedback Control Layer                                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  PID Controllers, Impedance Control, Balance Control       \u2502 \u2502\n\u2502  \u2502  Real-Time Joint Control                                    \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                 \u2502\n\u2502  Hardware Interface Layer                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  Motor Drivers, Actuator Control, Sensor Fusion            \u2502 \u2502\n\u2502  \u2502  Low-Level Hardware Abstraction                            \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h2,{id:"whole-body-control-framework",children:"Whole-Body Control Framework"}),"\n",(0,s.jsx)(n.h3,{id:"inverse-kinematics-solver",children:"Inverse Kinematics Solver"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom scipy.spatial.transform import Rotation as R\nimport casadi as ca\n\nclass InverseKinematicsSolver:\n    def __init__(self, robot_model):\n        self.model = robot_model\n        self.dof = len(robot_model.joint_names)\n\n        # Define symbolic variables\n        self.q = ca.MX.sym('q', self.dof)  # Joint angles\n        self.x_des = ca.MX.sym('x_des', 6)  # Desired pose (position + orientation)\n\n        # Forward kinematics functions\n        self.end_effector_fk = self.define_forward_kinematics()\n\n        # Optimization variables\n        self.opti = ca.Opti()\n        self.opt_q = self.opti.variable(self.dof)\n\n    def define_forward_kinematics(self):\n        \"\"\"Define forward kinematics for the robot\"\"\"\n        # This would use DH parameters or other kinematic model\n        # For simplicity, using a basic implementation\n        def fk(joint_angles):\n            # Calculate end-effector pose from joint angles\n            # This is a simplified example\n            ee_pose = np.zeros(6)  # [x, y, z, rx, ry, rz]\n\n            # Calculate based on robot model\n            # This would be more complex in practice\n            for i, angle in enumerate(joint_angles):\n                # Simplified forward kinematics calculation\n                pass\n\n            return ee_pose\n\n        return fk\n\n    def solve_ik(self, target_pose, current_joints, weights=None):\n        \"\"\"Solve inverse kinematics problem\"\"\"\n        if weights is None:\n            weights = np.ones(self.dof)\n\n        # Set up optimization problem\n        self.opti.set_initial(self.opt_q, current_joints)\n\n        # Objective: minimize joint deviations\n        objective = ca.mtimes(\n            (self.opt_q - current_joints).T,\n            ca.diag(weights),\n            (self.opt_q - current_joints)\n        )\n\n        # Add constraints\n        ee_pose = self.forward_kinematics(self.opt_q)\n        self.opti.subject_to(ca.norm_2(ee_pose[:3] - target_pose[:3]) <= 0.01)  # Position tolerance\n        self.opti.subject_to(ca.norm_2(ee_pose[3:] - target_pose[3:]) <= 0.1)  # Orientation tolerance\n\n        # Joint limits\n        for i, (name, limits) in enumerate(self.model.joint_limits.items()):\n            self.opti.subject_to(self.opt_q[i] >= limits['min'])\n            self.opti.subject_to(self.opt_q[i] <= limits['max'])\n\n        # Solve optimization\n        self.opti.minimize(objective)\n\n        # Set solver options\n        opts = {\n            'ipopt.print_level': 0,\n            'ipopt.sb': 'yes',\n            'print_time': 0\n        }\n        self.opti.solver('ipopt', opts)\n\n        try:\n            sol = self.opti.solve()\n            return sol.value(self.opt_q)\n        except:\n            # Return current joints if no solution found\n            return current_joints\n\n    def forward_kinematics(self, joint_angles):\n        \"\"\"Calculate forward kinematics\"\"\"\n        # Simplified implementation\n        # In practice, this would use the robot's DH parameters or URDF\n        pose = np.zeros(6)\n\n        # Calculate transformation matrices for each joint\n        T = np.eye(4)  # Homogeneous transformation\n\n        for i, angle in enumerate(joint_angles):\n            # Calculate joint transformation\n            # This is a simplified example\n            pass\n\n        return pose\n"})}),"\n",(0,s.jsx)(n.h3,{id:"whole-body-controller",children:"Whole-Body Controller"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom scipy.linalg import block_diag\n\nclass WholeBodyController:\n    def __init__(self, robot_model):\n        self.model = robot_model\n        self.mass_matrix = None\n        self.coriolis_matrix = None\n        self.gravity_vector = None\n\n        # Task priorities\n        self.tasks = {\n            'balance': {'priority': 1, 'weight': 1.0},\n            'end_effector': {'priority': 2, 'weight': 0.8},\n            'posture': {'priority': 3, 'weight': 0.5},\n            'obstacle_avoidance': {'priority': 4, 'weight': 0.3}\n        }\n\n        # Initialize controllers\n        self.balance_controller = BalanceController(robot_model)\n        self.impedance_controllers = {}\n        for joint_name in robot_model.joint_names:\n            self.impedance_controllers[joint_name] = ImpedanceController(\n                stiffness=100, damping=10\n            )\n\n    def compute_control(self, desired_states, current_states, external_forces=None):\n        \"\"\"Compute whole-body control torques\"\"\"\n        # Update robot dynamics\n        self.update_dynamics(current_states['joint_positions'],\n                           current_states['joint_velocities'])\n\n        # Compute task-space commands\n        task_commands = self.compute_task_commands(desired_states, current_states)\n\n        # Prioritize tasks using weighted least squares\n        joint_torques = self.prioritize_tasks(task_commands, current_states)\n\n        # Add gravity compensation\n        joint_torques += self.gravity_vector\n\n        # Add Coriolis and centrifugal terms\n        joint_torques += np.dot(self.coriolis_matrix, current_states['joint_velocities'])\n\n        return joint_torques\n\n    def compute_task_commands(self, desired_states, current_states):\n        \"\"\"Compute task-space commands for each priority\"\"\"\n        commands = {}\n\n        # Balance task\n        if 'balance' in desired_states:\n            commands['balance'] = self.balance_controller.compute_balance_torque(\n                desired_states['balance'], current_states\n            )\n\n        # End-effector task\n        if 'end_effector' in desired_states:\n            commands['end_effector'] = self.compute_end_effector_command(\n                desired_states['end_effector'], current_states\n            )\n\n        # Posture task\n        if 'posture' in desired_states:\n            commands['posture'] = self.compute_posture_command(\n                desired_states['posture'], current_states\n            )\n\n        return commands\n\n    def prioritize_tasks(self, task_commands, current_states):\n        \"\"\"Prioritize tasks using weighted least squares\"\"\"\n        # This implements the task-priority framework\n        # Higher priority tasks are satisfied first\n\n        # Construct task Jacobians\n        J_balance = self.compute_balance_jacobian(current_states)\n        J_ee = self.compute_end_effector_jacobian(current_states)\n        J_posture = self.compute_posture_jacobian(current_states)\n\n        # Construct stacked Jacobian matrix\n        J_stack = np.vstack([\n            self.tasks['balance']['weight'] * J_balance,\n            self.tasks['end_effector']['weight'] * J_ee,\n            self.tasks['posture']['weight'] * J_posture\n        ])\n\n        # Compute nullspace projection for lower priority tasks\n        # J_pinv = J_stack^T * (J_stack * J_stack^T)^(-1)\n        J_pinv = np.linalg.pinv(J_stack)\n\n        # Compute desired accelerations for each task\n        ddq_balance = task_commands['balance']\n        ddq_ee = task_commands['end_effector']\n        ddq_posture = task_commands['posture']\n\n        ddq_stack = np.hstack([\n            self.tasks['balance']['weight'] * ddq_balance,\n            self.tasks['end_effector']['weight'] * ddq_ee,\n            self.tasks['posture']['weight'] * ddq_posture\n        ])\n\n        # Compute joint accelerations\n        ddq = np.dot(J_pinv, ddq_stack)\n\n        # Compute joint torques using inverse dynamics\n        tau = np.dot(self.mass_matrix, ddq)\n\n        return tau\n\n    def update_dynamics(self, q, dq):\n        \"\"\"Update robot dynamics matrices\"\"\"\n        # Compute mass matrix M(q)\n        self.mass_matrix = self.compute_mass_matrix(q)\n\n        # Compute Coriolis matrix C(q,dq)\n        self.coriolis_matrix = self.compute_coriolis_matrix(q, dq)\n\n        # Compute gravity vector g(q)\n        self.gravity_vector = self.compute_gravity_vector(q)\n\n    def compute_mass_matrix(self, q):\n        \"\"\"Compute mass matrix using composite rigid body algorithm\"\"\"\n        # Simplified implementation\n        # In practice, this would use recursive Newton-Euler or other methods\n        return np.eye(len(q)) * 1.0  # Simplified diagonal matrix\n\n    def compute_coriolis_matrix(self, q, dq):\n        \"\"\"Compute Coriolis and centrifugal matrix\"\"\"\n        # Simplified implementation\n        return np.zeros((len(q), len(q)))\n\n    def compute_gravity_vector(self, q):\n        \"\"\"Compute gravity vector\"\"\"\n        # Simplified implementation\n        g = 9.81\n        return np.zeros(len(q))\n"})}),"\n",(0,s.jsx)(n.h2,{id:"balance-control-systems",children:"Balance Control Systems"}),"\n",(0,s.jsx)(n.h3,{id:"center-of-mass-com-control",children:"Center of Mass (CoM) Control"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom scipy import signal\nfrom collections import deque\n\nclass CoMController:\n    def __init__(self, robot_model, control_frequency=100):\n        self.model = robot_model\n        self.dt = 1.0 / control_frequency\n        self.control_frequency = control_frequency\n\n        # CoM tracking controller (PID)\n        self.com_pid = {\n            'x': {'kp': 1000.0, 'ki': 100.0, 'kd': 100.0, 'integral': 0.0, 'prev_error': 0.0},\n            'y': {'kp': 1000.0, 'ki': 100.0, 'kd': 100.0, 'integral': 0.0, 'prev_error': 0.0},\n            'z': {'kp': 500.0, 'ki': 50.0, 'kd': 50.0, 'integral': 0.0, 'prev_error': 0.0}\n        }\n\n        # Support polygon (convex hull of feet contact points)\n        self.support_polygon = None\n\n        # State estimation\n        self.com_position = np.array([0.0, 0.0, 0.8])  # Initial CoM position\n        self.com_velocity = np.array([0.0, 0.0, 0.0])\n        self.com_acceleration = np.array([0.0, 0.0, 0.0])\n\n        # IMU data\n        self.imu_orientation = np.array([0.0, 0.0, 0.0, 1.0])  # quaternion\n        self.imu_angular_velocity = np.array([0.0, 0.0, 0.0])\n        self.imu_linear_acceleration = np.array([0.0, 0.0, 9.81])\n\n        # Foot positions (relative to robot base)\n        self.left_foot_pos = np.array([0.0, 0.1, 0.0])  # Relative to robot base\n        self.right_foot_pos = np.array([0.0, -0.1, 0.0])\n\n        # Filters for sensor data\n        self.com_filter = LowPassFilter(cutoff_freq=10.0, dt=self.dt)\n\n    def update_sensor_data(self, imu_data, joint_positions, joint_velocities):\n        \"\"\"Update sensor data for balance control\"\"\"\n        # Update IMU data\n        self.imu_orientation = imu_data['orientation']\n        self.imu_angular_velocity = imu_data['angular_velocity']\n        self.imu_linear_acceleration = imu_data['linear_acceleration']\n\n        # Update CoM estimation\n        self.update_com_estimation(joint_positions, joint_velocities)\n\n        # Update support polygon\n        self.update_support_polygon()\n\n    def update_com_estimation(self, joint_positions, joint_velocities):\n        \"\"\"Estimate CoM position and velocity\"\"\"\n        # This would use the robot's kinematic model and joint positions\n        # For now, using simplified estimation\n\n        # Calculate CoM based on joint positions and masses\n        # This is a simplified example\n        total_mass = sum(self.model.link_masses)\n        com_pos = np.zeros(3)\n\n        for i, (joint_pos, mass) in enumerate(zip(joint_positions, self.model.link_masses)):\n            # Calculate contribution of each link to CoM\n            link_com = self.calculate_link_com(i, joint_pos)\n            com_pos += mass * link_com\n\n        com_pos /= total_mass\n\n        # Update CoM state with filtering\n        self.com_position = self.com_filter.filter(com_pos)\n\n        # Estimate velocity using finite difference\n        if hasattr(self, '_prev_com_pos'):\n            self.com_velocity = (self.com_position - self._prev_com_pos) / self.dt\n        self._prev_com_pos = self.com_position.copy()\n\n    def calculate_link_com(self, link_idx, joint_pos):\n        \"\"\"Calculate center of mass for a specific link\"\"\"\n        # Simplified calculation\n        # In practice, this would use the URDF/kinematic model\n        return joint_pos\n\n    def update_support_polygon(self):\n        \"\"\"Update support polygon based on foot contacts\"\"\"\n        # Calculate support polygon from foot positions\n        # This would depend on current stance (double support, single support)\n\n        if self.is_double_support():\n            # Both feet on ground\n            self.support_polygon = self.calculate_double_support_polygon()\n        else:\n            # Single foot support\n            support_foot = self.get_support_foot()\n            self.support_polygon = self.calculate_single_support_polygon(support_foot)\n\n    def is_double_support(self):\n        \"\"\"Check if in double support phase\"\"\"\n        # This would be determined by gait phase or contact sensors\n        return True  # Simplified assumption\n\n    def get_support_foot(self):\n        \"\"\"Get which foot is in support\"\"\"\n        # This would be determined by gait phase or contact sensors\n        return 'left'  # Simplified assumption\n\n    def calculate_double_support_polygon(self):\n        \"\"\"Calculate support polygon for double support\"\"\"\n        # Create convex hull of both feet\n        left_pos = self.left_foot_pos\n        right_pos = self.right_foot_pos\n\n        # Simple rectangle approximation\n        min_x, max_x = min(left_pos[0], right_pos[0]), max(left_pos[0], right_pos[0])\n        min_y, max_y = min(left_pos[1], right_pos[1]), max(left_pos[1], right_pos[1])\n\n        return np.array([\n            [min_x, min_y],\n            [max_x, min_y],\n            [max_x, max_y],\n            [min_x, max_y]\n        ])\n\n    def calculate_single_support_polygon(self, foot):\n        \"\"\"Calculate support polygon for single support\"\"\"\n        # Use foot size to define support polygon\n        foot_pos = self.left_foot_pos if foot == 'left' else self.right_foot_pos\n\n        # Simple rectangular support area\n        foot_size_x, foot_size_y = 0.1, 0.06  # Typical foot size\n\n        return np.array([\n            [foot_pos[0] - foot_size_x/2, foot_pos[1] - foot_size_y/2],\n            [foot_pos[0] + foot_size_x/2, foot_pos[1] - foot_size_y/2],\n            [foot_pos[0] + foot_size_x/2, foot_pos[1] + foot_size_y/2],\n            [foot_pos[0] - foot_size_x/2, foot_pos[1] + foot_size_y/2]\n        ])\n\n    def compute_balance_control(self, target_com_position):\n        \"\"\"Compute balance control torques\"\"\"\n        # Calculate CoM error\n        com_error = target_com_position - self.com_position\n\n        # Apply PID control for each axis\n        balance_torques = np.zeros(len(self.model.joint_names))\n\n        for axis_idx, axis_name in enumerate(['x', 'y', 'z']):\n            if axis_idx >= len(com_error):\n                continue\n\n            error = com_error[axis_idx]\n\n            # PID calculations\n            self.com_pid[axis_name]['integral'] += error * self.dt\n            derivative = (error - self.com_pid[axis_name]['prev_error']) / self.dt\n\n            # Saturation for integral term\n            self.com_pid[axis_name]['integral'] = np.clip(\n                self.com_pid[axis_name]['integral'], -1.0, 1.0\n            )\n\n            control_output = (\n                self.com_pid[axis_name]['kp'] * error +\n                self.com_pid[axis_name]['ki'] * self.com_pid[axis_name]['integral'] +\n                self.com_pid[axis_name]['kd'] * derivative\n            )\n\n            self.com_pid[axis_name]['prev_error'] = error\n\n            # Map CoM control to joint torques\n            # This would use the CoM Jacobian in practice\n            joint_torques = self.map_com_to_joints(control_output, axis_idx)\n            balance_torques += joint_torques\n\n        return balance_torques\n\n    def map_com_to_joints(self, com_control, axis_idx):\n        \"\"\"Map CoM control to joint torques\"\"\"\n        # This would use the CoM Jacobian in practice\n        # For now, return a simplified mapping\n        torques = np.zeros(len(self.model.joint_names))\n\n        # Simple mapping: torso joints for x/y CoM control, hip joints for z\n        if axis_idx == 0:  # x-axis (forward/back)\n            torques[6:12] = com_control * 0.1  # hip joints\n        elif axis_idx == 1:  # y-axis (lateral)\n            torques[6:12] = com_control * 0.1  # hip joints\n        elif axis_idx == 2:  # z-axis (vertical)\n            torques[0:6] = com_control * 0.05  # ankle joints\n\n        return torques\n"})}),"\n",(0,s.jsx)(n.h2,{id:"walking-control-systems",children:"Walking Control Systems"}),"\n",(0,s.jsx)(n.h3,{id:"walking-pattern-generator",children:"Walking Pattern Generator"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import numpy as np\nimport math\nfrom scipy import interpolate\n\nclass WalkingPatternGenerator:\n    def __init__(self, robot_model):\n        self.model = robot_model\n        self.gait_params = {\n            'step_length': 0.3,      # meters\n            'step_width': 0.2,       # meters (distance between feet)\n            'step_height': 0.05,     # meters (foot lift height)\n            'step_duration': 1.0,    # seconds per step\n            'stance_ratio': 0.6,     # portion of step in stance phase\n            'double_support_ratio': 0.1  # portion of step in double support\n        }\n\n        # Current gait state\n        self.current_phase = 0.0\n        self.current_support_foot = 'left'\n        self.step_count = 0\n\n        # Trajectory buffers\n        self.foot_trajectory = {'left': [], 'right': []}\n        self.com_trajectory = []\n\n    def set_walking_parameters(self, step_length=0.3, step_height=0.05, step_duration=1.0):\n        \"\"\"Set walking parameters\"\"\"\n        self.gait_params['step_length'] = step_length\n        self.gait_params['step_height'] = step_height\n        self.gait_params['step_duration'] = step_duration\n\n        # Adjust other parameters based on step length\n        self.gait_params['step_width'] = min(0.3, step_length * 0.66)  # Proportional to step length\n\n    def generate_step_trajectory(self, target_velocity, dt=0.01):\n        \"\"\"Generate walking trajectory for next step\"\"\"\n        # Update gait phase\n        self.current_phase += dt / self.gait_params['step_duration']\n\n        if self.current_phase >= 1.0:\n            # Complete step cycle\n            self.current_phase = 0.0\n            self.step_count += 1\n\n            # Switch support foot\n            self.current_support_foot = 'right' if self.current_support_foot == 'left' else 'left'\n\n        # Generate trajectories for both feet\n        left_foot_pos = self.generate_foot_trajectory('left', target_velocity)\n        right_foot_pos = self.generate_foot_trajectory('right', target_velocity)\n\n        # Generate CoM trajectory for balance\n        com_pos = self.generate_com_trajectory(target_velocity)\n\n        return {\n            'left_foot': left_foot_pos,\n            'right_foot': right_foot_pos,\n            'com': com_pos,\n            'phase': self.current_phase,\n            'support_foot': self.current_support_foot\n        }\n\n    def generate_foot_trajectory(self, foot_name, target_velocity):\n        \"\"\"Generate trajectory for a single foot\"\"\"\n        # Determine if this foot is swing foot (moving) or stance foot (stationary)\n        is_swing_foot = (foot_name != self.current_support_foot)\n\n        if not is_swing_foot:\n            # Stance foot - remains stationary or moves slowly to prepare for next step\n            return self.calculate_stance_foot_position(foot_name)\n        else:\n            # Swing foot - follows predefined trajectory\n            return self.calculate_swing_foot_trajectory(foot_name, target_velocity)\n\n    def calculate_stance_foot_position(self, foot_name):\n        \"\"\"Calculate position of stance foot\"\"\"\n        # Stance foot moves to prepare for next step\n        # For simplicity, keep at current position with slight adjustments\n        if foot_name == 'left':\n            base_pos = np.array([0.0, 0.1, 0.0])  # nominal left foot position\n        else:\n            base_pos = np.array([0.0, -0.1, 0.0])  # nominal right foot position\n\n        # Add small adjustments based on phase\n        phase_progress = self.current_phase\n        if phase_progress < self.gait_params['stance_ratio']:\n            # Early stance - foot moves forward slightly\n            base_pos[0] += self.gait_params['step_length'] * phase_progress / self.gait_params['stance_ratio']\n        else:\n            # Late stance / double support - prepare for lift-off\n            base_pos[0] += self.gait_params['step_length']\n\n        return base_pos\n\n    def calculate_swing_foot_trajectory(self, foot_name, target_velocity):\n        \"\"\"Calculate trajectory for swing foot\"\"\"\n        # Use cycloidal trajectory for smooth foot movement\n        # Phase within the swing phase\n        stance_end = self.gait_params['stance_ratio']\n        double_support_end = stance_end + self.gait_params['double_support_ratio']\n\n        if self.current_phase < stance_end or self.current_phase > double_support_end:\n            # Foot should be on ground in stance phase\n            return self.calculate_stance_foot_position(foot_name)\n        else:\n            # Calculate swing phase progress\n            swing_start = stance_end\n            swing_duration = 1.0 - stance_end - self.gait_params['double_support_ratio']\n            swing_phase = (self.current_phase - swing_start) / swing_duration\n\n            # Previous support foot position (where swing foot started)\n            prev_support_pos = self.calculate_stance_foot_position(\n                'right' if self.current_support_foot == 'left' else 'left'\n            )\n\n            # Target position (where swing foot should land)\n            target_pos = prev_support_pos.copy()\n            target_pos[0] += self.gait_params['step_length']  # Move forward\n\n            # Apply target velocity adjustments\n            target_pos[0] += target_velocity[0] * self.gait_params['step_duration'] / 2.0  # Forward\n            target_pos[1] -= target_velocity[1] * self.gait_params['step_duration'] * 0.1  # Lateral adjustment\n\n            # Cycloidal trajectory for smooth motion\n            x_progress = self.cycloidal_interpolation(0, self.gait_params['step_length'], swing_phase)\n            y_progress = self.cycloidal_interpolation(\n                0, 0, swing_phase  # No lateral movement for this foot\n            )\n            z_progress = self.parabolic_interpolation(\n                0, self.gait_params['step_height'], swing_phase\n            )\n\n            # Calculate current foot position\n            foot_pos = prev_support_pos.copy()\n            foot_pos[0] += x_progress\n            foot_pos[1] += y_progress\n            foot_pos[2] += z_progress\n\n            return foot_pos\n\n    def generate_com_trajectory(self, target_velocity):\n        \"\"\"Generate CoM trajectory for balance during walking\"\"\"\n        # Generate CoM trajectory that maintains balance during walking\n        # Use inverted pendulum model for CoM motion\n\n        # Desired CoM position based on ZMP (Zero Moment Point) concept\n        com_x = target_velocity[0] * self.current_phase * self.gait_params['step_duration'] / 2.0\n        com_y = 0.0  # Maintain centered position\n        com_z = 0.8  # Maintain constant height\n\n        # Add small oscillations to mimic natural walking\n        oscillation_freq = 1.0 / self.gait_params['step_duration']\n        oscillation_amp = 0.01\n\n        com_x += oscillation_amp * math.sin(2 * math.pi * oscillation_freq * self.current_phase * self.gait_params['step_duration'])\n        com_y += oscillation_amp * 0.5 * math.sin(4 * math.pi * oscillation_freq * self.current_phase * self.gait_params['step_duration'])\n\n        return np.array([com_x, com_y, com_z])\n\n    def cycloidal_interpolation(self, start, end, t):\n        \"\"\"Cycloidal interpolation for smooth motion\"\"\"\n        # Cycloidal motion: smooth acceleration/deceleration\n        if t <= 0:\n            return start\n        elif t >= 1:\n            return end\n        else:\n            # Cycloidal equation: s = s0 + (s1-s0) * (t - sin(2\u03c0t)/(2\u03c0))\n            return start + (end - start) * (t - math.sin(2 * math.pi * t) / (2 * math.pi))\n\n    def parabolic_interpolation(self, start, peak, t):\n        \"\"\"Parabolic interpolation for foot lift\"\"\"\n        if t <= 0.5:\n            # Rising parabola\n            return start + (peak - start) * (2 * t)**2\n        else:\n            # Falling parabola\n            return peak - (peak - start) * (2 * (t - 0.5))**2\n"})}),"\n",(0,s.jsx)(n.h2,{id:"control-integration",children:"Control Integration"}),"\n",(0,s.jsx)(n.h3,{id:"integrated-control-system",children:"Integrated Control System"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\nclass IntegratedControlSystem(Node):\n    def __init__(self):\n        super().__init__('integrated_control_system')\n\n        # Initialize subsystems\n        self.whole_body_controller = WholeBodyController(self.robot_model)\n        self.com_controller = CoMController(self.robot_model)\n        self.walking_generator = WalkingPatternGenerator(self.robot_model)\n\n        # ROS 2 interfaces\n        self.joint_state_sub = self.create_subscription(\n            JointState, '/joint_states', self.joint_state_callback, 10\n        )\n        self.imu_sub = self.create_subscription(\n            Imu, '/imu/data', self.imu_callback, 10\n        )\n        self.cmd_vel_sub = self.create_subscription(\n            Twist, '/cmd_vel', self.cmd_vel_callback, 10\n        )\n        self.joint_cmd_pub = self.create_publisher(\n            Float64MultiArray, '/joint_commands', 10\n        )\n\n        # State variables\n        self.current_joint_positions = None\n        self.current_joint_velocities = None\n        self.current_imu_data = None\n        self.target_velocity = np.array([0.0, 0.0, 0.0])  # [linear_x, linear_y, angular_z]\n\n        # Control timer\n        self.control_timer = self.create_timer(0.01, self.control_callback)  # 100Hz\n\n    def joint_state_callback(self, msg):\n        \"\"\"Update joint state\"\"\"\n        if self.current_joint_positions is None:\n            self.current_joint_positions = np.zeros(len(msg.name))\n            self.current_joint_velocities = np.zeros(len(msg.name))\n\n        for i, name in enumerate(msg.name):\n            try:\n                idx = self.robot_model.joint_names.index(name)\n                self.current_joint_positions[idx] = msg.position[i]\n                if i < len(msg.velocity):\n                    self.current_joint_velocities[idx] = msg.velocity[i]\n            except ValueError:\n                continue\n\n    def imu_callback(self, msg):\n        \"\"\"Update IMU data\"\"\"\n        self.current_imu_data = {\n            'orientation': [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w],\n            'angular_velocity': [msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z],\n            'linear_acceleration': [msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z]\n        }\n\n    def cmd_vel_callback(self, msg):\n        \"\"\"Update target velocity\"\"\"\n        self.target_velocity = np.array([msg.linear.x, msg.linear.y, msg.angular.z])\n\n    def control_callback(self):\n        \"\"\"Main control loop\"\"\"\n        if (self.current_joint_positions is None or\n            self.current_joint_velocities is None or\n            self.current_imu_data is None):\n            return\n\n        # Update sensor data in controllers\n        self.com_controller.update_sensor_data(\n            self.current_imu_data,\n            self.current_joint_positions,\n            self.current_joint_velocities\n        )\n\n        # Generate walking pattern if walking\n        walking_trajectory = None\n        if np.linalg.norm(self.target_velocity[:2]) > 0.01:  # If moving\n            walking_trajectory = self.walking_generator.generate_step_trajectory(\n                self.target_velocity\n            )\n\n        # Define desired states for whole-body controller\n        desired_states = {}\n\n        if walking_trajectory:\n            # Use walking trajectory for balance and foot placement\n            desired_states['balance'] = walking_trajectory['com']\n            desired_states['left_foot'] = walking_trajectory['left_foot']\n            desired_states['right_foot'] = walking_trajectory['right_foot']\n        else:\n            # Standing balance\n            desired_states['balance'] = np.array([0.0, 0.0, 0.8])  # Stable CoM position\n\n        # Current states\n        current_states = {\n            'joint_positions': self.current_joint_positions,\n            'joint_velocities': self.current_joint_velocities\n        }\n\n        # Compute control torques\n        joint_torques = self.whole_body_controller.compute_control(\n            desired_states, current_states\n        )\n\n        # Publish joint commands\n        cmd_msg = Float64MultiArray()\n        cmd_msg.data = joint_torques.tolist()\n        self.joint_cmd_pub.publish(cmd_msg)\n\n        # Log control performance\n        self.get_logger().debug(f'Control torques: {joint_torques[:3]}...')  # First 3 joints\n"})}),"\n",(0,s.jsx)(n.h2,{id:"exercise-implement-control-system",children:"Exercise: Implement Control System"}),"\n",(0,s.jsx)(n.p,{children:"Create a complete control system that:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Integrates whole-body control with balance maintenance"}),"\n",(0,s.jsx)(n.li,{children:"Implements stable walking patterns"}),"\n",(0,s.jsx)(n.li,{children:"Handles transitions between standing and walking"}),"\n",(0,s.jsx)(n.li,{children:"Includes safety mechanisms for balance recovery"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"The humanoid robot control systems form the foundation of stable and coordinated movement. The hierarchical control architecture ensures that high-level behaviors are properly translated into low-level joint commands while maintaining balance and safety. The integration of whole-body control, balance maintenance, and walking pattern generation enables the robot to perform complex locomotion tasks while maintaining stability."}),"\n",(0,s.jsx)(n.hr,{})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(_,{...e})}):_(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>i});var o=t(6540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);