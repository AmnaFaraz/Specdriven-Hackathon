"use strict";(globalThis.webpackChunkphysical_humanoid_robotics_book=globalThis.webpackChunkphysical_humanoid_robotics_book||[]).push([[264],{7174(e,n,a){a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"modules/module-1/module-1-chapter-4","title":"ROS 2 Packages for Humanoid Robots","description":"This chapter covers specialized ROS 2 packages and tools specifically designed for humanoid robot development and control.","source":"@site/content/modules/module-1/chapter-4.md","sourceDirName":"modules/module-1","slug":"/modules/module-1/module-1-chapter-4","permalink":"/docs/modules/module-1/module-1-chapter-4","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-humanoid-robotics/physical-humanoid-robotics-book/tree/main/packages/create-docusaurus/templates/shared/content/modules/module-1/chapter-4.md","tags":[],"version":"current","frontMatter":{"id":"module-1-chapter-4","title":"ROS 2 Packages for Humanoid Robots","sidebar_label":"Humanoid Packages"},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Control","permalink":"/docs/modules/module-1/module-1-chapter-3"},"next":{"title":"Best Practices","permalink":"/docs/modules/module-1/module-1-chapter-5"}}');var o=a(4848),i=a(8453);const t={id:"module-1-chapter-4",title:"ROS 2 Packages for Humanoid Robots",sidebar_label:"Humanoid Packages"},s="ROS 2 Packages for Humanoid Robots",l={},c=[{value:"Navigation2 for Humanoid Robots",id:"navigation2-for-humanoid-robots",level:2},{value:"Control Frameworks",id:"control-frameworks",level:2},{value:"ros2_control",id:"ros2_control",level:3},{value:"Hardware Interface",id:"hardware-interface",level:2},{value:"URDF for Humanoid Robots",id:"urdf-for-humanoid-robots",level:2},{value:"Exercise: Create a URDF for a Simple Humanoid",id:"exercise-create-a-urdf-for-a-simple-humanoid",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"ros-2-packages-for-humanoid-robots",children:"ROS 2 Packages for Humanoid Robots"})}),"\n",(0,o.jsx)(n.p,{children:"This chapter covers specialized ROS 2 packages and tools specifically designed for humanoid robot development and control."}),"\n",(0,o.jsx)(n.h2,{id:"navigation2-for-humanoid-robots",children:"Navigation2 for Humanoid Robots"}),"\n",(0,o.jsx)(n.p,{children:"Navigation2 is the standard navigation stack for ROS 2, but it requires special configuration for humanoid robots:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'# Example configuration for humanoid navigation\n# navigation2_params.yaml\namcl:\n  ros__parameters:\n    use_sim_time: False\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_footprint"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    laser_max_range: 100.0\n    laser_min_range: -1.0\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\n    save_pose_rate: 0.5\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.2\n    update_min_d: 0.25\n    z_hit: 0.5\n    z_max: 0.05\n    z_rand: 0.5\n    z_short: 0.05\n'})}),"\n",(0,o.jsx)(n.h2,{id:"control-frameworks",children:"Control Frameworks"}),"\n",(0,o.jsx)(n.h3,{id:"ros2_control",children:"ros2_control"}),"\n",(0,o.jsx)(n.p,{children:"The ros2_control framework provides a standardized way to interface with robot hardware:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Controller Manager Configuration --\x3e\n<controller_manager>\n  <rosparam file="$(find my_humanoid_robot_control)/config/humanoid_controllers.yaml"/>\n  <controller name="joint_state_broadcaster" type="joint_state_broadcaster/JointStateBroadcaster"/>\n  <controller name="humanoid_controller" type="position_controllers/JointTrajectoryController">\n    <param name="joints">left_hip_yaw left_hip_roll left_hip_pitch left_knee left_ankle_pitch left_ankle_roll right_hip_yaw right_hip_roll right_hip_pitch right_knee right_ankle_pitch right_ankle_roll left_shoulder_pitch left_shoulder_roll left_elbow right_shoulder_pitch right_shoulder_roll right_elbow</param>\n  </controller>\n</controller_manager>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"hardware-interface",children:"Hardware Interface"}),"\n",(0,o.jsx)(n.p,{children:"Creating a hardware interface for humanoid robots:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'// Example hardware interface for humanoid robot\n#include "hardware_interface/types/hardware_interface_type_values.hpp"\n#include "rclcpp/rclcpp.hpp"\n\nnamespace my_humanoid_hardware_interface\n{\nclass MyHumanoidHardware : public hardware_interface::SystemInterface\n{\npublic:\n  hardware_interface::CallbackReturn on_init(\n    const hardware_interface::HardwareInfo & info) override\n  {\n    if (SystemInterface::on_init(info) != CallbackReturn::SUCCESS) {\n      return CallbackReturn::ERROR;\n    }\n\n    // Initialize joint data structures\n    for (const hardware_interface::ComponentInfo & joint : info_.joints) {\n      joint_names_.push_back(joint.name);\n\n      // Initialize state and command interfaces\n      if (joint.command_interfaces.size() != 1) {\n        return CallbackReturn::ERROR;\n      }\n\n      if (joint.state_interfaces.size() != 2) {  // position and velocity\n        return CallbackReturn::ERROR;\n      }\n    }\n\n    return CallbackReturn::SUCCESS;\n  }\n\n  std::vector<hardware_interface::StateInterface> export_state_interfaces() override\n  {\n    std::vector<hardware_interface::StateInterface> state_interfaces;\n    for (auto i = 0u; i < joint_names_.size(); i++) {\n      state_interfaces.emplace_back(\n        joint_names_[i],\n        hardware_interface::HW_IF_POSITION,\n        &hw_positions_[i]);\n      state_interfaces.emplace_back(\n        joint_names_[i],\n        hardware_interface::HW_IF_VELOCITY,\n        &hw_velocities_[i]);\n    }\n\n    return state_interfaces;\n  }\n\n  std::vector<hardware_interface::CommandInterface> export_command_interfaces() override\n  {\n    std::vector<hardware_interface::CommandInterface> command_interfaces;\n    for (auto i = 0u; i < joint_names_.size(); i++) {\n      command_interfaces.emplace_back(\n        joint_names_[i],\n        hardware_interface::HW_IF_POSITION,\n        &hw_commands_[i]);\n    }\n\n    return command_interfaces;\n  }\n\n  hardware_interface::CallbackReturn on_activate(\n    const rclcpp_lifecycle::State & previous_state) override\n  {\n    return SystemInterface::on_activate(previous_state);\n  }\n\n  hardware_interface::CallbackReturn on_deactivate(\n    const rclcpp_lifecycle::State & previous_state) override\n  {\n    return SystemInterface::on_deactivate(previous_state);\n  }\n\n  hardware_interface::return_type read(\n    const rclcpp::Time & time, const rclcpp::Duration & period) override\n  {\n    // Read joint states from hardware\n    for (auto i = 0u; i < joint_names_.size(); i++) {\n      // hw_positions_[i] = read_position_from_hardware(i);\n      // hw_velocities_[i] = read_velocity_from_hardware(i);\n    }\n    return hardware_interface::return_type::OK;\n  }\n\n  hardware_interface::return_type write(\n    const rclcpp::Time & time, const rclcpp::Duration & period) override\n  {\n    // Send commands to hardware\n    for (auto i = 0u; i < joint_names_.size(); i++) {\n      // write_position_to_hardware(i, hw_commands_[i]);\n    }\n    return hardware_interface::return_type::OK;\n  }\n\nprivate:\n  std::vector<std::string> joint_names_;\n  std::vector<double> hw_commands_;\n  std::vector<double> hw_positions_;\n  std::vector<double> hw_velocities_;\n};\n}  // namespace my_humanoid_hardware_interface\n\n#include "pluginlib/class_list_macros.hpp"\nPLUGINLIB_EXPORT_CLASS(\n  my_humanoid_hardware_interface::MyHumanoidHardware, hardware_interface::SystemInterface)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"urdf-for-humanoid-robots",children:"URDF for Humanoid Robots"}),"\n",(0,o.jsx)(n.p,{children:"The Unified Robot Description Format (URDF) is crucial for humanoid robots:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.1 0.1 0.1"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 0.8 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.1 0.1 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Torso --\x3e\n  <joint name="base_to_torso" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.5"/>\n  </joint>\n\n  <link name="torso">\n    <visual>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n      <material name="gray">\n        <color rgba="0.5 0.5 0.5 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="5"/>\n      <inertia ixx="0.2" ixy="0" ixz="0" iyy="0.3" iyz="0" izz="0.2"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head --\x3e\n  <joint name="torso_to_head" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.35"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n  </joint>\n\n  <link name="head">\n    <visual>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n      <material name="white">\n        <color rgba="1 1 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1"/>\n      <inertia ixx="0.004" ixy="0" ixz="0" iyy="0.004" iyz="0" izz="0.004"/>\n    </inertial>\n  </link>\n</robot>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"exercise-create-a-urdf-for-a-simple-humanoid",children:"Exercise: Create a URDF for a Simple Humanoid"}),"\n",(0,o.jsx)(n.p,{children:"Create a complete URDF file for a simple 6-DOF humanoid robot with:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Base link"}),"\n",(0,o.jsx)(n.li,{children:"Torso"}),"\n",(0,o.jsx)(n.li,{children:"Head"}),"\n",(0,o.jsx)(n.li,{children:"Two arms (shoulder, elbow)"}),"\n",(0,o.jsx)(n.li,{children:"Two legs (hip, knee, ankle)"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 provides specialized packages and frameworks for humanoid robot development, from navigation to hardware control. Understanding these packages is essential for building sophisticated humanoid robots."}),"\n",(0,o.jsx)(n.hr,{})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,n,a){a.d(n,{R:()=>t,x:()=>s});var r=a(6540);const o={},i=r.createContext(o);function t(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);