"use strict";(globalThis.webpackChunkphysical_humanoid_robotics_book=globalThis.webpackChunkphysical_humanoid_robotics_book||[]).push([[855],{5386(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"modules/module-2/module-2-chapter-4","title":"Simulation to Reality Transfer (Sim-to-Real)","description":"Sim-to-real transfer is the process of taking behaviors, controllers, or learned policies from simulation and successfully deploying them on real robots. This is a critical challenge in robotics.","source":"@site/content/modules/module-2/chapter-4.md","sourceDirName":"modules/module-2","slug":"/modules/module-2/module-2-chapter-4","permalink":"/docs/modules/module-2/module-2-chapter-4","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-humanoid-robotics/physical-humanoid-robotics-book/tree/main/packages/create-docusaurus/templates/shared/content/modules/module-2/chapter-4.md","tags":[],"version":"current","frontMatter":{"id":"module-2-chapter-4","title":"Simulation to Reality Transfer (Sim-to-Real)","sidebar_label":"Sim-to-Real Transfer"},"sidebar":"tutorialSidebar","previous":{"title":"Unity Simulation","permalink":"/docs/modules/module-2/module-2-chapter-3"},"next":{"title":"Digital Twin Integration","permalink":"/docs/modules/module-2/module-2-chapter-5"}}');var r=i(4848),t=i(8453);const o={id:"module-2-chapter-4",title:"Simulation to Reality Transfer (Sim-to-Real)",sidebar_label:"Sim-to-Real Transfer"},s="Simulation to Reality Transfer (Sim-to-Real)",l={},d=[{value:"The Reality Gap Problem",id:"the-reality-gap-problem",level:2},{value:"Physical Differences",id:"physical-differences",level:3},{value:"Solutions to Reality Gap",id:"solutions-to-reality-gap",level:3},{value:"Domain Randomization",id:"domain-randomization",level:2},{value:"System Identification",id:"system-identification",level:2},{value:"Adaptive Control for Sim-to-Real",id:"adaptive-control-for-sim-to-real",level:2},{value:"Progressive Domain Transfer",id:"progressive-domain-transfer",level:2},{value:"Phase 1: Pure Simulation",id:"phase-1-pure-simulation",level:3},{value:"Phase 2: Enhanced Simulation",id:"phase-2-enhanced-simulation",level:3},{value:"Phase 3: Reality-Matched Simulation",id:"phase-3-reality-matched-simulation",level:3},{value:"Phase 4: Reality with Safety",id:"phase-4-reality-with-safety",level:3},{value:"Unity-Specific Sim-to-Real Considerations",id:"unity-specific-sim-to-real-considerations",level:2},{value:"Perception Simulation",id:"perception-simulation",level:3},{value:"Exercise: Implement Domain Randomization",id:"exercise-implement-domain-randomization",level:2},{value:"Summary",id:"summary",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"simulation-to-reality-transfer-sim-to-real",children:"Simulation to Reality Transfer (Sim-to-Real)"})}),"\n",(0,r.jsx)(n.p,{children:"Sim-to-real transfer is the process of taking behaviors, controllers, or learned policies from simulation and successfully deploying them on real robots. This is a critical challenge in robotics."}),"\n",(0,r.jsx)(n.h2,{id:"the-reality-gap-problem",children:"The Reality Gap Problem"}),"\n",(0,r.jsx)(n.p,{children:'The "reality gap" refers to the differences between simulated and real environments that can cause policies learned in simulation to fail when deployed on real robots:'}),"\n",(0,r.jsx)(n.h3,{id:"physical-differences",children:"Physical Differences"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamics"}),": Mass, friction, and inertia may not be accurately modeled"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actuator Behavior"}),": Real actuators have delays, non-linearities, and limitations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor Noise"}),": Real sensors have noise, latency, and calibration errors"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Environmental Conditions"}),": Lighting, temperature, and surface properties vary"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"solutions-to-reality-gap",children:"Solutions to Reality Gap"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Domain Randomization"}),": Randomize simulation parameters to improve robustness"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"System Identification"}),": Calibrate simulation models to match real robot behavior"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Adaptive Control"}),": Adjust controllers based on real-world feedback"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Progressive Transfer"}),": Gradually move from simulation to reality"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,r.jsx)(n.p,{children:"Domain randomization involves training in simulations with randomized parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import random\n\nclass DomainRandomization:\n    def __init__(self):\n        self.param_ranges = {\n            'robot_mass': (0.8, 1.2),  # 80% to 120% of nominal\n            'friction_coeff': (0.5, 1.5),\n            'sensor_noise': (0.0, 0.05),\n            'actuator_delay': (0.0, 0.02),  # 0-20ms delay\n        }\n\n    def randomize_environment(self):\n        \"\"\"Randomize environment parameters\"\"\"\n        randomized_params = {}\n        for param, (min_val, max_val) in self.param_ranges.items():\n            randomized_params[param] = random.uniform(min_val, max_val)\n        return randomized_params\n\n    def apply_randomization(self, sim_env, params):\n        \"\"\"Apply randomized parameters to simulation\"\"\"\n        sim_env.robot.mass = params['robot_mass'] * nominal_mass\n        sim_env.friction_coeff = params['friction_coeff']\n        sim_env.sensor_noise_level = params['sensor_noise']\n        sim_env.actuator_delay = params['actuator_delay']\n"})}),"\n",(0,r.jsx)(n.h2,{id:"system-identification",children:"System Identification"}),"\n",(0,r.jsx)(n.p,{children:"System identification involves calibrating simulation parameters to match real robot behavior:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom scipy.optimize import minimize\n\nclass SystemIdentification:\n    def __init__(self, real_robot, sim_robot):\n        self.real_robot = real_robot\n        self.sim_robot = sim_robot\n        self.parameters = {\n            'mass': 1.0,\n            'inertia': 0.1,\n            'friction': 0.01,\n            'gear_ratio': 1.0\n        }\n\n    def objective_function(self, params):\n        \"\"\"Objective function to minimize difference between real and sim\"\"\"\n        # Set simulation parameters\n        self.sim_robot.set_params({\n            'mass': params[0],\n            'inertia': params[1],\n            'friction': params[2],\n            'gear_ratio': params[3]\n        })\n\n        # Run identical commands on both robots\n        real_response = self.real_robot.execute_trajectory(test_trajectory)\n        sim_response = self.sim_robot.execute_trajectory(test_trajectory)\n\n        # Calculate error\n        error = np.mean((real_response - sim_response) ** 2)\n        return error\n\n    def identify_parameters(self):\n        \"\"\"Identify optimal parameters\"\"\"\n        initial_params = [1.0, 0.1, 0.01, 1.0]  # Initial guess\n        result = minimize(\n            self.objective_function,\n            initial_params,\n            method='BFGS'\n        )\n\n        self.parameters = {\n            'mass': result.x[0],\n            'inertia': result.x[1],\n            'friction': result.x[2],\n            'gear_ratio': result.x[3]\n        }\n        return self.parameters\n"})}),"\n",(0,r.jsx)(n.h2,{id:"adaptive-control-for-sim-to-real",children:"Adaptive Control for Sim-to-Real"}),"\n",(0,r.jsx)(n.p,{children:"Adaptive controllers adjust their behavior based on real-world feedback:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class AdaptiveController:\n    def __init__(self):\n        self.sim_controller = PDController()\n        self.adaptation_gain = 0.01\n        self.param_error_integrator = 0.0\n\n    def update(self, state_error, sim_state, real_state):\n        # Base control from simulation\n        base_control = self.sim_controller.compute(state_error)\n\n        # Adaptation based on sim-to-real discrepancy\n        state_discrepancy = real_state - sim_state\n        self.param_error_integrator += state_discrepancy * 0.01  # dt\n\n        adaptation_term = self.adaptation_gain * (\n            state_discrepancy + self.param_error_integrator\n        )\n\n        # Final control command\n        final_control = base_control + adaptation_term\n\n        return final_control\n"})}),"\n",(0,r.jsx)(n.h2,{id:"progressive-domain-transfer",children:"Progressive Domain Transfer"}),"\n",(0,r.jsx)(n.p,{children:"A systematic approach to transfer from simulation to reality:"}),"\n",(0,r.jsx)(n.h3,{id:"phase-1-pure-simulation",children:"Phase 1: Pure Simulation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Train in idealized simulation"}),"\n",(0,r.jsx)(n.li,{children:"Focus on basic behaviors"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"phase-2-enhanced-simulation",children:"Phase 2: Enhanced Simulation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Add noise and disturbances"}),"\n",(0,r.jsx)(n.li,{children:"Include actuator limitations"}),"\n",(0,r.jsx)(n.li,{children:"Randomize physical parameters"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"phase-3-reality-matched-simulation",children:"Phase 3: Reality-Matched Simulation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Calibrate simulation to match real robot"}),"\n",(0,r.jsx)(n.li,{children:"Use identified parameters"}),"\n",(0,r.jsx)(n.li,{children:"Validate on real robot"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"phase-4-reality-with-safety",children:"Phase 4: Reality with Safety"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Deploy on real robot with safety limits"}),"\n",(0,r.jsx)(n.li,{children:"Monitor performance"}),"\n",(0,r.jsx)(n.li,{children:"Collect data for improvement"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"unity-specific-sim-to-real-considerations",children:"Unity-Specific Sim-to-Real Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"perception-simulation",children:"Perception Simulation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// In Unity, simulate sensor noise and limitations\npublic class SimulatedCamera : MonoBehaviour\n{\n    public float noiseLevel = 0.01f;\n    public float blurRadius = 0.5f;\n\n    void Update()\n    {\n        // Add noise to captured images\n        RenderTexture.active = captureTexture;\n        Texture2D image = new Texture2D(Screen.width, Screen.height);\n        image.ReadPixels(new Rect(0, 0, Screen.width, Screen.height), 0, 0);\n        image.Apply();\n\n        // Apply noise and blur to simulate real sensor limitations\n        ApplyNoiseAndBlur(image);\n    }\n\n    void ApplyNoiseAndBlur(Texture2D image)\n    {\n        // Add random noise to pixels\n        for (int x = 0; x < image.width; x++)\n        {\n            for (int y = 0; y < image.height; y++)\n            {\n                Color pixel = image.GetPixel(x, y);\n                float noise = Random.Range(-noiseLevel, noiseLevel);\n                pixel.r += noise;\n                pixel.g += noise;\n                pixel.b += noise;\n                image.SetPixel(x, y, pixel);\n            }\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"exercise-implement-domain-randomization",children:"Exercise: Implement Domain Randomization"}),"\n",(0,r.jsx)(n.p,{children:"Create a simulation environment with randomized parameters for:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Robot mass (\xb120%)"}),"\n",(0,r.jsx)(n.li,{children:"Joint friction (\xb150%)"}),"\n",(0,r.jsx)(n.li,{children:"Sensor noise levels"}),"\n",(0,r.jsx)(n.li,{children:"Actuator delays"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Train a simple controller in this randomized environment and test its performance on a fixed parameter environment."}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Sim-to-real transfer is essential for making simulation useful in real robotics applications. By using domain randomization, system identification, adaptive control, and progressive transfer techniques, we can bridge the reality gap and successfully deploy simulation-trained behaviors on real robots."}),"\n",(0,r.jsx)(n.hr,{})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},8453(e,n,i){i.d(n,{R:()=>o,x:()=>s});var a=i(6540);const r={},t=a.createContext(r);function o(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);