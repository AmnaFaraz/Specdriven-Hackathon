"use strict";(globalThis.webpackChunkphysical_humanoid_robotics_book=globalThis.webpackChunkphysical_humanoid_robotics_book||[]).push([[792],{3268(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"modules/module-1/module-1-chapter-3","title":"ROS 2 for Humanoid Robot Control","description":"This chapter focuses on applying ROS 2 concepts specifically to humanoid robot control systems, which require precise coordination of multiple joints and sensors.","source":"@site/content/modules/module-1/chapter-3.md","sourceDirName":"modules/module-1","slug":"/modules/module-1/module-1-chapter-3","permalink":"/ur/docs/modules/module-1/module-1-chapter-3","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-humanoid-robotics/physical-humanoid-robotics-book/tree/main/packages/create-docusaurus/templates/shared/content/modules/module-1/chapter-3.md","tags":[],"version":"current","frontMatter":{"id":"module-1-chapter-3","title":"ROS 2 for Humanoid Robot Control","sidebar_label":"Humanoid Control"},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Patterns","permalink":"/ur/docs/modules/module-1/module-1-chapter-2"},"next":{"title":"Humanoid Packages","permalink":"/ur/docs/modules/module-1/module-1-chapter-4"}}');var i=t(4848),r=t(8453);const s={id:"module-1-chapter-3",title:"ROS 2 for Humanoid Robot Control",sidebar_label:"Humanoid Control"},l="ROS 2 for Humanoid Robot Control",a={},c=[{value:"Humanoid Robot Architecture",id:"humanoid-robot-architecture",level:2},{value:"Joint State Management",id:"joint-state-management",level:2},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:2},{value:"Balance Control with ROS 2",id:"balance-control-with-ros-2",level:2},{value:"Exercise: Implement a Simple Joint Controller",id:"exercise-implement-a-simple-joint-controller",level:2},{value:"Summary",id:"summary",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ros-2-for-humanoid-robot-control",children:"ROS 2 for Humanoid Robot Control"})}),"\n",(0,i.jsx)(n.p,{children:"This chapter focuses on applying ROS 2 concepts specifically to humanoid robot control systems, which require precise coordination of multiple joints and sensors."}),"\n",(0,i.jsx)(n.h2,{id:"humanoid-robot-architecture",children:"Humanoid Robot Architecture"}),"\n",(0,i.jsx)(n.p,{children:"Humanoid robots present unique challenges in ROS 2 due to their complex kinematic chains and real-time control requirements. A typical humanoid robot architecture includes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Joint Controllers"}),": Individual motor controllers for each joint"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor Managers"}),": IMU, force/torque sensors, cameras, etc."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Motion Planning"}),": Trajectory generation and inverse kinematics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Balance Control"}),": Center of mass management and fall prevention"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Estimation"}),": Joint position, velocity, and external forces"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"joint-state-management",children:"Joint State Management"}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robots, managing joint states is critical. The joint_state_publisher and robot_state_publisher packages are essential:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\nimport math\n\nclass JointStatePublisher(Node):\n    def __init__(self):\n        super().__init__('joint_state_publisher')\n        self.publisher_ = self.create_publisher(JointState, 'joint_states', 10)\n        self.timer = self.create_timer(0.05, self.timer_callback)  # 20 Hz\n\n        # Define joint names for a simple humanoid\n        self.joint_names = [\n            'left_hip_yaw', 'left_hip_roll', 'left_hip_pitch',\n            'left_knee', 'left_ankle_pitch', 'left_ankle_roll',\n            'right_hip_yaw', 'right_hip_roll', 'right_hip_pitch',\n            'right_knee', 'right_ankle_pitch', 'right_ankle_roll',\n            'left_shoulder_pitch', 'left_shoulder_roll', 'left_elbow',\n            'right_shoulder_pitch', 'right_shoulder_roll', 'right_elbow'\n        ]\n\n        self.joint_positions = [0.0] * len(self.joint_names)\n        self.joint_velocities = [0.0] * len(self.joint_names)\n        self.joint_efforts = [0.0] * len(self.joint_names)\n\n    def timer_callback(self):\n        msg = JointState()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.name = self.joint_names\n        msg.position = self.joint_positions\n        msg.velocity = self.joint_velocities\n        msg.effort = self.joint_efforts\n\n        self.publisher_.publish(msg)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,i.jsx)(n.p,{children:"Humanoid robots require sophisticated walking pattern generation. ROS 2 can coordinate multiple nodes to achieve stable locomotion:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nimport numpy as np\n\nclass WalkingPatternGenerator(Node):\n    def __init__(self):\n        super().__init__(\'walking_pattern_generator\')\n        self.publisher_ = self.create_publisher(\n            JointTrajectory,\n            \'joint_trajectory\',\n            10\n        )\n\n    def generate_step_trajectory(self, step_length, step_height, step_time):\n        """Generate a trajectory for a single step"""\n        msg = JointTrajectory()\n        msg.joint_names = self.get_joint_names()\n\n        # Generate trajectory points\n        num_points = int(step_time * 100)  # 100Hz control\n        time_step = step_time / num_points\n\n        for i in range(num_points + 1):\n            point = JointTrajectoryPoint()\n            t = i * time_step / step_time  # normalized time [0, 1]\n\n            # Generate joint positions for walking motion\n            hip_pitch = self.calculate_hip_pitch(t, step_length)\n            knee_angle = self.calculate_knee_angle(t, step_height)\n            ankle_angle = self.calculate_ankle_angle(t)\n\n            point.positions = self.calculate_joint_positions(\n                hip_pitch, knee_angle, ankle_angle\n            )\n            point.time_from_start.sec = int(i * time_step)\n            point.time_from_start.nanosec = int((i * time_step % 1) * 1e9)\n\n            msg.points.append(point)\n\n        return msg\n'})}),"\n",(0,i.jsx)(n.h2,{id:"balance-control-with-ros-2",children:"Balance Control with ROS 2"}),"\n",(0,i.jsx)(n.p,{children:"Balance control is crucial for humanoid robots. Here's how to implement a basic balance controller:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu\nfrom geometry_msgs.msg import Vector3\nfrom std_msgs.msg import Float64MultiArray\n\nclass BalanceController(Node):\n    def __init__(self):\n        super().__init__('balance_controller')\n        self.imu_subscriber = self.create_subscription(\n            Imu, 'imu/data', self.imu_callback, 10\n        )\n        self.com_publisher = self.create_publisher(\n            Float64MultiArray, 'center_of_mass_cmd', 10\n        )\n\n        self.roll = 0.0\n        self.pitch = 0.0\n        self.yaw = 0.0\n\n        # PID controller parameters\n        self.kp = 10.0\n        self.ki = 0.5\n        self.kd = 2.0\n        self.integral = 0.0\n        self.previous_error = 0.0\n\n    def imu_callback(self, msg):\n        # Extract orientation from quaternion\n        w, x, y, z = msg.orientation.w, msg.orientation.x, msg.orientation.y, msg.orientation.z\n\n        # Convert to roll, pitch, yaw\n        self.roll = math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y))\n        self.pitch = math.asin(2 * (w * y - z * x))\n        self.yaw = math.atan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z))\n\n        # Simple balance correction\n        self.balance_correction()\n\n    def balance_correction(self):\n        target_pitch = 0.0  # Target is upright\n        error = target_pitch - self.pitch\n\n        # PID control\n        self.integral += error * 0.01  # Assuming 100Hz update rate\n        derivative = (error - self.previous_error) / 0.01\n\n        control_output = (self.kp * error) + (self.ki * self.integral) + (self.kd * derivative)\n\n        self.previous_error = error\n\n        # Publish correction command\n        cmd_msg = Float64MultiArray()\n        cmd_msg.data = [control_output]  # Simplified for example\n        self.com_publisher.publish(cmd_msg)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"exercise-implement-a-simple-joint-controller",children:"Exercise: Implement a Simple Joint Controller"}),"\n",(0,i.jsx)(n.p,{children:"Create a ROS 2 node that implements a position controller for a single joint. The node should:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Subscribe to a joint command topic"}),"\n",(0,i.jsx)(n.li,{children:"Use a PID controller to track the desired position"}),"\n",(0,i.jsx)(n.li,{children:"Publish the resulting effort to an actuator interface"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 provides the necessary tools for controlling humanoid robots, from basic joint management to complex walking and balance control. Understanding these patterns is essential for building stable and capable humanoid robots."}),"\n",(0,i.jsx)(n.hr,{})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},8453(e,n,t){t.d(n,{R:()=>s,x:()=>l});var o=t(6540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);