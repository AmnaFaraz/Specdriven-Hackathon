"use strict";(globalThis.webpackChunkphysical_humanoid_robotics_book=globalThis.webpackChunkphysical_humanoid_robotics_book||[]).push([[802],{5481(e,n,o){o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>_,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"modules/module-3/module-3-chapter-4","title":"Isaac Manipulation and Control","description":"This chapter explores how NVIDIA Isaac enables sophisticated manipulation and control capabilities for robotic systems, particularly relevant for humanoid robots with complex manipulation requirements.","source":"@site/content/modules/module-3/chapter-4.md","sourceDirName":"modules/module-3","slug":"/modules/module-3/module-3-chapter-4","permalink":"/ur/docs/modules/module-3/module-3-chapter-4","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-humanoid-robotics/physical-humanoid-robotics-book/tree/main/packages/create-docusaurus/templates/shared/content/modules/module-3/chapter-4.md","tags":[],"version":"current","frontMatter":{"id":"module-3-chapter-4","title":"Isaac Manipulation and Control","sidebar_label":"Isaac Manipulation"},"sidebar":"tutorialSidebar","previous":{"title":"Isaac Planning","permalink":"/ur/docs/modules/module-3/module-3-chapter-3"},"next":{"title":"Isaac Learning","permalink":"/ur/docs/modules/module-3/module-3-chapter-5"}}');var s=o(4848),r=o(8453);const i={id:"module-3-chapter-4",title:"Isaac Manipulation and Control",sidebar_label:"Isaac Manipulation"},a="Isaac Manipulation and Control",l={},c=[{value:"Isaac Manipulation Framework",id:"isaac-manipulation-framework",level:2},{value:"Isaac Motion Planning",id:"isaac-motion-planning",level:2},{value:"Trajectory Generation",id:"trajectory-generation",level:3},{value:"Isaac Grasping System",id:"isaac-grasping-system",level:2},{value:"AI-Powered Grasp Planning",id:"ai-powered-grasp-planning",level:3},{value:"Isaac Force Control",id:"isaac-force-control",level:2},{value:"Impedance Control for Safe Interaction",id:"impedance-control-for-safe-interaction",level:3},{value:"Isaac Multi-Arm Coordination",id:"isaac-multi-arm-coordination",level:2},{value:"Coordinated Manipulation",id:"coordinated-manipulation",level:3},{value:"Exercise: Implement Coordinated Grasping",id:"exercise-implement-coordinated-grasping",level:2},{value:"Summary",id:"summary",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"isaac-manipulation-and-control",children:"Isaac Manipulation and Control"})}),"\n",(0,s.jsx)(n.p,{children:"This chapter explores how NVIDIA Isaac enables sophisticated manipulation and control capabilities for robotic systems, particularly relevant for humanoid robots with complex manipulation requirements."}),"\n",(0,s.jsx)(n.h2,{id:"isaac-manipulation-framework",children:"Isaac Manipulation Framework"}),"\n",(0,s.jsx)(n.p,{children:"Isaac Manipulation includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Motion Planning"}),": Trajectory generation for complex manipulation tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Grasping"}),": AI-powered grasp planning and execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Force Control"}),": Precise force and torque control for delicate operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Arm Coordination"}),": Control of multiple manipulator arms"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"isaac-motion-planning",children:"Isaac Motion Planning"}),"\n",(0,s.jsx)(n.h3,{id:"trajectory-generation",children:"Trajectory Generation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom moveit_msgs.msg import MoveItErrorCodes\nfrom sensor_msgs.msg import JointState\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\nclass IsaacMotionPlanner(Node):\n    def __init__(self):\n        super().__init__('isaac_motion_planner')\n\n        # Subscriptions\n        self.joint_state_sub = self.create_subscription(\n            JointState, '/joint_states', self.joint_state_callback, 10\n        )\n        self.goal_pose_sub = self.create_subscription(\n            PoseStamped, '/manipulation_goal', self.goal_pose_callback, 10\n        )\n\n        # Publishers\n        self.trajectory_pub = self.create_publisher(\n            JointTrajectory, '/joint_trajectory', 10\n        )\n\n        # Robot parameters\n        self.joint_names = [\n            'shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint',\n            'wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint'\n        ]\n        self.current_joint_positions = [0.0] * len(self.joint_names)\n\n    def joint_state_callback(self, msg):\n        \"\"\"Update current joint positions\"\"\"\n        for i, name in enumerate(self.joint_names):\n            if name in msg.name:\n                idx = msg.name.index(name)\n                self.current_joint_positions[i] = msg.position[idx]\n\n    def plan_trajectory(self, start_pos, goal_pos, duration=5.0):\n        \"\"\"Plan smooth trajectory between start and goal positions\"\"\"\n        # Use cubic spline interpolation for smooth motion\n        t_points = np.array([0, duration/3, 2*duration/3, duration])\n        positions = np.array([start_pos,\n                             (np.array(start_pos) + np.array(goal_pos))/2,  # Midpoint\n                             (np.array(start_pos) + 2*np.array(goal_pos))/3,  # Weighted toward goal\n                             goal_pos])\n\n        # Create interpolated functions for each joint\n        trajectory = JointTrajectory()\n        trajectory.joint_names = self.joint_names\n\n        # Generate trajectory points\n        num_points = int(duration * 50)  # 50Hz trajectory\n        time_step = duration / num_points\n\n        for i in range(num_points + 1):\n            t = i * time_step\n\n            # Interpolate position for each joint\n            point = JointTrajectoryPoint()\n            point.positions = []\n\n            for j in range(len(self.joint_names)):\n                # Cubic interpolation\n                x = t_points\n                y = positions[:, j]\n\n                # Fit cubic polynomial\n                coeffs = np.polyfit(x, y, 3)\n                pos = np.polyval(coeffs, t)\n\n                point.positions.append(pos)\n\n            # Calculate velocities (derivative of position)\n            point.velocities = []\n            for j in range(len(self.joint_names)):\n                coeffs = np.polyfit(t_points, positions[:, j], 3)\n                # Derivative: 3*a*t^2 + 2*b*t + c\n                vel = 3*coeffs[0]*t**2 + 2*coeffs[1]*t + coeffs[2]\n                point.velocities.append(vel)\n\n            # Calculate accelerations (second derivative)\n            point.accelerations = []\n            for j in range(len(self.joint_names)):\n                coeffs = np.polyfit(t_points, positions[:, j], 3)\n                # Second derivative: 6*a*t + 2*b\n                acc = 6*coeffs[0]*t + 2*coeffs[1]\n                point.accelerations.append(acc)\n\n            point.time_from_start.sec = int(t)\n            point.time_from_start.nanosec = int((t - int(t)) * 1e9)\n\n            trajectory.points.append(point)\n\n        return trajectory\n\n    def execute_trajectory(self, trajectory):\n        \"\"\"Execute the planned trajectory\"\"\"\n        self.trajectory_pub.publish(trajectory)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"isaac-grasping-system",children:"Isaac Grasping System"}),"\n",(0,s.jsx)(n.h3,{id:"ai-powered-grasp-planning",children:"AI-Powered Grasp Planning"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import PointCloud2, Image\nfrom geometry_msgs.msg import Pose, PoseArray\nfrom std_msgs.msg import Bool\nfrom isaac_ros_apriltag_interfaces.msg import AprilTagDetectionArray\nfrom visualization_msgs.msg import MarkerArray\nimport numpy as np\nimport open3d as o3d\n\nclass IsaacGraspPlanner(Node):\n    def __init__(self):\n        super().__init__(\'isaac_grasp_planner\')\n\n        # Subscriptions\n        self.pointcloud_sub = self.create_subscription(\n            PointCloud2, \'/camera/depth/points\', self.pointcloud_callback, 10\n        )\n        self.detection_sub = self.create_subscription(\n            AprilTagDetectionArray, \'/apriltag_detections\', self.detection_callback, 10\n        )\n\n        # Publishers\n        self.grasp_poses_pub = self.create_publisher(PoseArray, \'/grasp_poses\', 10)\n        self.grasp_command_pub = self.create_publisher(Bool, \'/grasp_command\', 10)\n        self.visualization_pub = self.create_publisher(MarkerArray, \'/grasp_visualization\', 10)\n\n        self.pointcloud_data = None\n        self.object_poses = []\n\n    def pointcloud_callback(self, msg):\n        """Process point cloud for grasp planning"""\n        # Convert PointCloud2 to numpy array\n        self.pointcloud_data = self.pointcloud2_to_array(msg)\n\n        # Segment objects from point cloud\n        segmented_objects = self.segment_objects(self.pointcloud_data)\n\n        # Plan grasps for each object\n        for obj in segmented_objects:\n            grasps = self.plan_grasps_for_object(obj)\n            self.publish_grasp_candidates(grasps)\n\n    def segment_objects(self, pointcloud):\n        """Segment individual objects from point cloud"""\n        # Convert to Open3D point cloud\n        pcd = o3d.geometry.PointCloud()\n        pcd.points = o3d.utility.Vector3dVector(pointcloud[:, :3])\n\n        # Apply statistical outlier removal\n        pcd, _ = pcd.remove_statistical_outlier(nb_neighbors=20, std_ratio=2.0)\n\n        # Plane segmentation to remove ground\n        plane_model, inliers = pcd.segment_plane(\n            distance_threshold=0.01,\n            ransac_n=3,\n            num_iterations=1000\n        )\n\n        # Remove ground plane points\n        object_cloud = pcd.select_by_index(inliers, invert=True)\n\n        # Cluster remaining points to identify objects\n        labels = np.array(object_cloud.cluster_dbscan(eps=0.02, min_points=10))\n\n        # Group points by cluster\n        objects = []\n        for label in set(labels):\n            if label == -1:  # Skip noise points\n                continue\n            mask = labels == label\n            obj_points = np.asarray(object_cloud.points)[mask]\n            objects.append(obj_points)\n\n        return objects\n\n    def plan_grasps_for_object(self, object_points):\n        """Plan potential grasps for an object"""\n        grasps = []\n\n        # Calculate object properties\n        centroid = np.mean(object_points, axis=0)\n        size = np.max(object_points, axis=0) - np.min(object_points, axis=0)\n\n        # Generate grasp candidates around the object\n        for angle in np.linspace(0, 2*np.pi, 8):\n            for height_ratio in [0.3, 0.5, 0.7]:  # Different grasp heights\n                grasp_pose = self.calculate_grasp_pose(\n                    centroid, size, angle, height_ratio\n                )\n\n                # Score the grasp based on geometric properties\n                score = self.score_grasp(grasp_pose, object_points)\n\n                if score > 0.5:  # Threshold for valid grasp\n                    grasps.append({\n                        \'pose\': grasp_pose,\n                        \'score\': score,\n                        \'approach_direction\': self.calculate_approach_direction(grasp_pose)\n                    })\n\n        # Sort grasps by score\n        grasps.sort(key=lambda x: x[\'score\'], reverse=True)\n        return grasps[:5]  # Return top 5 grasps\n\n    def calculate_grasp_pose(self, centroid, size, angle, height_ratio):\n        """Calculate grasp pose based on object properties"""\n        pose = Pose()\n\n        # Position grasp at object centroid with height offset\n        pose.position.x = centroid[0]\n        pose.position.y = centroid[1]\n        pose.position.z = centroid[2] + size[2] * height_ratio\n\n        # Orient gripper to approach from the side\n        pose.orientation.x = 0.0\n        pose.orientation.y = 0.0\n        pose.orientation.z = np.sin(angle / 2)\n        pose.orientation.w = np.cos(angle / 2)\n\n        return pose\n\n    def score_grasp(self, pose, object_points):\n        """Score grasp based on geometric feasibility"""\n        # Check if grasp is collision-free\n        collision_score = self.check_grasp_collision(pose, object_points)\n\n        # Check grasp stability\n        stability_score = self.evaluate_grasp_stability(pose, object_points)\n\n        # Combine scores\n        total_score = 0.6 * stability_score + 0.4 * collision_score\n\n        return total_score\n\n    def execute_grasp(self, grasp_pose):\n        """Execute the selected grasp"""\n        # Move to pre-grasp position\n        pre_grasp = self.calculate_pre_grasp_pose(grasp_pose)\n        self.move_to_pose(pre_grasp)\n\n        # Approach the object\n        self.move_to_pose(grasp_pose)\n\n        # Close gripper\n        self.close_gripper()\n\n        # Lift object\n        self.lift_object()\n\n        # Move to destination\n        # (Implementation would include collision checking and path planning)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"isaac-force-control",children:"Isaac Force Control"}),"\n",(0,s.jsx)(n.h3,{id:"impedance-control-for-safe-interaction",children:"Impedance Control for Safe Interaction"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import WrenchStamped, Twist\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\nclass IsaacImpedanceController(Node):\n    def __init__(self):\n        super().__init__(\'isaac_impedance_controller\')\n\n        # Subscriptions\n        self.wrench_sub = self.create_subscription(\n            WrenchStamped, \'/wrench\', self.wrench_callback, 10\n        )\n        self.joint_state_sub = self.create_subscription(\n            JointState, \'/joint_states\', self.joint_state_callback, 10\n        )\n\n        # Publishers\n        self.impedance_cmd_pub = self.create_publisher(\n            Float64MultiArray, \'/impedance_command\', 10\n        )\n        self.velocity_cmd_pub = self.create_publisher(Twist, \'/velocity_command\', 10)\n\n        # Impedance control parameters\n        self.stiffness = np.diag([1000, 1000, 1000, 100, 100, 100])  # [x,y,z,R,P,Y]\n        self.damping = np.diag([100, 100, 100, 10, 10, 10])\n        self.mass = np.diag([10, 10, 10, 1, 1, 1])\n\n        # Force limits for safety\n        self.max_force = 50.0  # Newtons\n        self.max_torque = 5.0  # Nm\n\n        self.current_wrench = np.zeros(6)  # [fx, fy, fz, mx, my, mz]\n        self.current_velocity = np.zeros(6)  # [vx, vy, vz, wx, wy, wz]\n\n    def wrench_callback(self, msg):\n        """Update current wrench measurements"""\n        self.current_wrench = np.array([\n            msg.wrench.force.x,\n            msg.wrench.force.y,\n            msg.wrench.force.z,\n            msg.wrench.torque.x,\n            msg.wrench.torque.y,\n            msg.wrench.torque.z\n        ])\n\n    def joint_state_callback(self, msg):\n        """Update joint state information"""\n        # Process joint positions, velocities, efforts\n        pass\n\n    def compute_impedance_force(self, desired_pose, current_pose):\n        """Compute impedance-based force command"""\n        # Calculate pose error\n        pose_error = desired_pose - current_pose\n\n        # Apply impedance model: F = K * x + D * v + M * a\n        # For simplicity, using only stiffness term\n        impedance_force = np.dot(self.stiffness, pose_error[:6])\n\n        # Limit force for safety\n        force_magnitude = np.linalg.norm(impedance_force[:3])\n        torque_magnitude = np.linalg.norm(impedance_force[3:])\n\n        if force_magnitude > self.max_force:\n            impedance_force[:3] = (impedance_force[:3] / force_magnitude) * self.max_force\n\n        if torque_magnitude > self.max_torque:\n            impedance_force[3:] = (impedance_force[3:] / torque_magnitude) * self.max_torque\n\n        return impedance_force\n\n    def safety_check(self, force_command):\n        """Check if force command is safe to execute"""\n        force_mag = np.linalg.norm(force_command[:3])\n        torque_mag = np.linalg.norm(force_command[3:])\n\n        if force_mag > self.max_force or torque_mag > self.max_torque:\n            self.get_logger().warn(f"Force command exceeds safety limits: F={force_mag}, T={torque_mag}")\n            return False\n\n        return True\n\n    def control_loop(self):\n        """Main impedance control loop"""\n        # Get desired pose from higher-level planner\n        desired_pose = self.get_desired_pose()\n        current_pose = self.get_current_pose()\n\n        # Compute impedance force\n        impedance_force = self.compute_impedance_force(desired_pose, current_pose)\n\n        # Add compliance to external forces\n        compliant_force = impedance_force - 0.1 * self.current_wrench  # Damping effect\n\n        # Safety check\n        if self.safety_check(compliant_force):\n            # Publish impedance command\n            cmd_msg = Float64MultiArray()\n            cmd_msg.data = compliant_force.tolist()\n            self.impedance_cmd_pub.publish(cmd_msg)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"isaac-multi-arm-coordination",children:"Isaac Multi-Arm Coordination"}),"\n",(0,s.jsx)(n.h3,{id:"coordinated-manipulation",children:"Coordinated Manipulation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Pose, Twist\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Bool\nimport numpy as np\n\nclass IsaacMultiArmCoordinator(Node):\n    def __init__(self):\n        super().__init__(\'isaac_multi_arm_coordinator\')\n\n        # Subscriptions for both arms\n        self.left_joint_sub = self.create_subscription(\n            JointState, \'/left_arm/joint_states\', self.left_joint_callback, 10\n        )\n        self.right_joint_sub = self.create_subscription(\n            JointState, \'/right_arm/joint_states\', self.right_joint_callback, 10\n        )\n\n        self.left_ee_sub = self.create_subscription(\n            Pose, \'/left_arm/ee_pose\', self.left_ee_callback, 10\n        )\n        self.right_ee_sub = self.create_subscription(\n            Pose, \'/right_arm/ee_pose\', self.right_ee_callback, 10\n        )\n\n        # Publishers\n        self.left_cmd_pub = self.create_publisher(JointTrajectory, \'/left_arm/command\', 10)\n        self.right_cmd_pub = self.create_publisher(JointTrajectory, \'/right_arm/command\', 10)\n        self.coordinated_status_pub = self.create_publisher(Bool, \'/coordinated_status\', 10)\n\n        # Arm states\n        self.left_joint_pos = []\n        self.right_joint_pos = []\n        self.left_ee_pose = None\n        self.right_ee_pose = None\n\n    def left_joint_callback(self, msg):\n        """Update left arm joint state"""\n        self.left_joint_pos = list(msg.position)\n\n    def right_joint_callback(self, msg):\n        """Update right arm joint state"""\n        self.right_joint_pos = list(msg.position)\n\n    def left_ee_callback(self, msg):\n        """Update left arm end-effector pose"""\n        self.left_ee_pose = msg\n\n    def right_ee_callback(self, msg):\n        """Update right arm end-effector pose"""\n        self.right_ee_pose = msg\n\n    def coordinate_arms_for_task(self, task_type):\n        """Coordinate both arms for specific tasks"""\n        if task_type == "lifting":\n            return self.coordinate_for_lifting()\n        elif task_type == "assembly":\n            return self.coordinate_for_assembly()\n        elif task_type == "transport":\n            return self.coordinate_for_transport()\n        else:\n            return self.default_coordination()\n\n    def coordinate_for_lifting(self):\n        """Coordinate arms for lifting heavy objects"""\n        # Calculate optimal grasp positions\n        if self.left_ee_pose and self.right_ee_pose:\n            # Calculate center of mass and grasp positions\n            center_pos = self.calculate_center_of_mass()\n\n            # Position arms on opposite sides of object\n            left_target = self.calculate_grasp_position(center_pos, "left")\n            right_target = self.calculate_grasp_position(center_pos, "right")\n\n            # Plan coordinated trajectories\n            left_traj = self.plan_coordinated_trajectory("left", left_target)\n            right_traj = self.plan_coordinated_trajectory("right", right_target)\n\n            # Ensure synchronized execution\n            self.execute_synchronized_trajectories(left_traj, right_traj)\n\n    def calculate_center_of_mass(self):\n        """Calculate object center of mass for coordinated lifting"""\n        # This would use perception data to estimate object COM\n        # For now, return midpoint between end-effectors\n        if self.left_ee_pose and self.right_ee_pose:\n            center_x = (self.left_ee_pose.position.x + self.right_ee_pose.position.x) / 2\n            center_y = (self.left_ee_pose.position.y + self.right_ee_pose.position.y) / 2\n            center_z = (self.left_ee_pose.position.z + self.right_ee_pose.position.z) / 2\n            return np.array([center_x, center_y, center_z])\n        return np.array([0, 0, 0])\n\n    def execute_synchronized_trajectories(self, left_traj, right_traj):\n        """Execute trajectories with synchronization"""\n        # Ensure both arms start simultaneously\n        start_time = self.get_clock().now()\n\n        # Execute trajectories with coordination\n        self.left_cmd_pub.publish(left_traj)\n        self.right_cmd_pub.publish(right_traj)\n\n        # Monitor for coordination errors\n        self.monitor_coordination()\n\n    def monitor_coordination(self):\n        """Monitor coordination between arms"""\n        if self.left_ee_pose and self.right_ee_pose:\n            # Calculate distance between end-effectors\n            dist = self.calculate_distance(self.left_ee_pose, self.right_ee_pose)\n\n            # Check if within expected coordination bounds\n            if dist > self.max_coordination_distance:\n                self.get_logger().warn("Arms coordination error: distance too large")\n                self.emergency_stop()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"exercise-implement-coordinated-grasping",children:"Exercise: Implement Coordinated Grasping"}),"\n",(0,s.jsx)(n.p,{children:"Create a system that:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Detects objects in the environment"}),"\n",(0,s.jsx)(n.li,{children:"Plans coordinated grasps for dual-arm robot"}),"\n",(0,s.jsx)(n.li,{children:"Executes synchronized manipulation"}),"\n",(0,s.jsx)(n.li,{children:"Monitors for safety and coordination errors"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Isaac provides sophisticated manipulation and control capabilities that enable complex robotic tasks. From motion planning to grasp execution, force control, and multi-arm coordination, these capabilities are essential for humanoid robots that need to interact with their environment in meaningful ways."}),"\n",(0,s.jsx)(n.hr,{})]})}function _(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453(e,n,o){o.d(n,{R:()=>i,x:()=>a});var t=o(6540);const s={},r=t.createContext(s);function i(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);