"use strict";(globalThis.webpackChunkphysical_humanoid_robotics_book=globalThis.webpackChunkphysical_humanoid_robotics_book||[]).push([[647],{3456(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"modules/module-1/module-1-chapter-5","title":"ROS 2 Best Practices for Humanoid Systems","description":"This chapter covers best practices and design patterns specifically for humanoid robot systems using ROS 2.","source":"@site/content/modules/module-1/chapter-5.md","sourceDirName":"modules/module-1","slug":"/modules/module-1/module-1-chapter-5","permalink":"/ur/docs/modules/module-1/module-1-chapter-5","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-humanoid-robotics/physical-humanoid-robotics-book/tree/main/packages/create-docusaurus/templates/shared/content/modules/module-1/chapter-5.md","tags":[],"version":"current","frontMatter":{"id":"module-1-chapter-5","title":"ROS 2 Best Practices for Humanoid Systems","sidebar_label":"Best Practices"},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Packages","permalink":"/ur/docs/modules/module-1/module-1-chapter-4"},"next":{"title":"Digital Twin Basics","permalink":"/ur/docs/modules/module-2/module-2-chapter-1"}}');var i=n(4848),s=n(8453);const r={id:"module-1-chapter-5",title:"ROS 2 Best Practices for Humanoid Systems",sidebar_label:"Best Practices"},a="ROS 2 Best Practices for Humanoid Systems",l={},c=[{value:"Real-time Considerations",id:"real-time-considerations",level:2},{value:"Real-time Setup",id:"real-time-setup",level:3},{value:"Real-time Scheduling in ROS 2",id:"real-time-scheduling-in-ros-2",level:3},{value:"Safety and Fault Tolerance",id:"safety-and-fault-tolerance",level:2},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"System Architecture Patterns",id:"system-architecture-patterns",level:2},{value:"Component-Based Architecture",id:"component-based-architecture",level:3},{value:"Exercise: Implement a Safety Layer",id:"exercise-implement-a-safety-layer",level:2},{value:"Summary",id:"summary",level:2}];function m(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"ros-2-best-practices-for-humanoid-systems",children:"ROS 2 Best Practices for Humanoid Systems"})}),"\n",(0,i.jsx)(t.p,{children:"This chapter covers best practices and design patterns specifically for humanoid robot systems using ROS 2."}),"\n",(0,i.jsx)(t.h2,{id:"real-time-considerations",children:"Real-time Considerations"}),"\n",(0,i.jsx)(t.p,{children:"Humanoid robots often require real-time performance for stability and safety. Here are key considerations:"}),"\n",(0,i.jsx)(t.h3,{id:"real-time-setup",children:"Real-time Setup"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"# Configure system for real-time performance\necho 'session required pam_limit.so rtprio 99' | sudo tee -a /etc/pam.d/common-session\necho 'session required pam_limit.so memlock unlimited' | sudo tee -a /etc/pam.d/common-session\n"})}),"\n",(0,i.jsx)(t.h3,{id:"real-time-scheduling-in-ros-2",children:"Real-time Scheduling in ROS 2"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"import rclpy\nfrom rclpy.qos import QoSProfile\nfrom rclpy.node import Node\nimport threading\nimport os\n\nclass RealtimeController(Node):\n    def __init__(self):\n        super().__init__('realtime_controller')\n\n        # Set real-time priority for critical threads\n        self.set_realtime_priority()\n\n        # Create timer with high frequency for control loop\n        self.control_timer = self.create_timer(\n            0.001,  # 1kHz control loop\n            self.control_callback,\n            clock=self.get_clock()\n        )\n\n    def set_realtime_priority(self):\n        try:\n            import sched\n            import os\n            # Set real-time scheduling policy (requires proper system setup)\n            pid = os.getpid()\n            # Note: This requires proper system configuration and privileges\n        except ImportError:\n            self.get_logger().warn(\"Real-time scheduling not available\")\n\n    def control_callback(self):\n        # Critical control code here\n        # This should execute in under 1ms to maintain 1kHz\n        pass\n"})}),"\n",(0,i.jsx)(t.h2,{id:"safety-and-fault-tolerance",children:"Safety and Fault Tolerance"}),"\n",(0,i.jsx)(t.p,{children:"Safety is paramount in humanoid robotics:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Bool\nimport time\n\nclass SafetyMonitor(Node):\n    def __init__(self):\n        super().__init__('safety_monitor')\n\n        self.joint_state_sub = self.create_subscription(\n            JointState, 'joint_states', self.joint_state_callback, 10\n        )\n\n        self.emergency_stop_pub = self.create_publisher(\n            Bool, 'emergency_stop', 10\n        )\n\n        self.joint_limits = {\n            'left_hip_pitch': (-1.5, 1.5),\n            'right_hip_pitch': (-1.5, 1.5),\n            'left_knee': (0.0, 2.5),\n            'right_knee': (0.0, 2.5),\n            # Add more joint limits...\n        }\n\n        self.last_state_time = time.time()\n        self.state_timeout = 0.1  # 100ms timeout\n\n        # Timer for safety checks\n        self.safety_timer = self.create_timer(0.01, self.safety_check)  # 100Hz\n\n    def joint_state_callback(self, msg):\n        self.last_state_time = time.time()\n\n        # Check joint limits\n        for i, name in enumerate(msg.name):\n            if name in self.joint_limits:\n                pos = msg.position[i]\n                min_limit, max_limit = self.joint_limits[name]\n\n                if pos < min_limit or pos > max_limit:\n                    self.trigger_emergency_stop(f\"Joint {name} out of limits: {pos}\")\n                    return\n\n    def safety_check(self):\n        # Check for communication timeouts\n        if time.time() - self.last_state_time > self.state_timeout:\n            self.trigger_emergency_stop(\"Joint state timeout\")\n            return\n\n        # Additional safety checks can be added here\n        # - Velocity limits\n        # - Acceleration limits\n        # - Balance checks\n        # - Collision detection\n\n    def trigger_emergency_stop(self, reason):\n        self.get_logger().error(f\"EMERGENCY STOP: {reason}\")\n        msg = Bool()\n        msg.data = True\n        self.emergency_stop_pub.publish(msg)\n"})}),"\n",(0,i.jsx)(t.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(t.p,{children:"Optimizing performance for humanoid robots:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, QoSHistoryPolicy, QoSReliabilityPolicy\nfrom builtin_interfaces.msg import Time\nimport numpy as np\nfrom scipy import linalg\n\nclass OptimizedController(Node):\n    def __init__(self):\n        super().__init__('optimized_controller')\n\n        # Use appropriate QoS for performance\n        qos_profile = QoSProfile(\n            history=QoSHistoryPolicy.RMW_QOS_HISTORY_KEEP_LAST,\n            depth=1,  # Only keep latest message\n            reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,\n            # Use best effort for high-frequency data where occasional drops are acceptable\n        )\n\n        self.sensor_sub = self.create_subscription(\n            JointState, 'joint_states', self.optimized_callback, qos_profile\n        )\n\n        # Pre-allocate arrays to avoid memory allocation during execution\n        self.joint_positions = np.zeros(18)  # Pre-allocated array\n        self.joint_velocities = np.zeros(18)  # Pre-allocated array\n\n    def optimized_callback(self, msg):\n        # Convert to numpy arrays once, reuse pre-allocated arrays\n        self.joint_positions[:len(msg.position)] = msg.position\n        self.joint_velocities[:len(msg.velocity)] = msg.velocity\n\n        # Perform calculations using optimized numpy operations\n        # Avoid creating temporary objects in the callback\n        self.compute_control_output()\n\n    def compute_control_output(self):\n        # Efficient control computation\n        # Use vectorized operations where possible\n        pass\n"})}),"\n",(0,i.jsx)(t.h2,{id:"system-architecture-patterns",children:"System Architecture Patterns"}),"\n",(0,i.jsx)(t.h3,{id:"component-based-architecture",children:"Component-Based Architecture"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Separation of concerns for humanoid robot system\nclass HumanoidSystemManager:\n    def __init__(self):\n        # Initialize subsystems\n        self.motion_controller = MotionController()\n        self.balance_controller = BalanceController()\n        self.safety_monitor = SafetyMonitor()\n        self.state_estimator = StateEstimator()\n\n    def update(self, dt):\n        # Update subsystems in appropriate order\n        self.state_estimator.update(dt)\n        self.balance_controller.update(dt, self.state_estimator.get_state())\n        self.motion_controller.update(dt, self.balance_controller.get_commands())\n        self.safety_monitor.update(dt, self.motion_controller.get_commands())\n"})}),"\n",(0,i.jsx)(t.h2,{id:"exercise-implement-a-safety-layer",children:"Exercise: Implement a Safety Layer"}),"\n",(0,i.jsx)(t.p,{children:"Create a safety layer that monitors:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Joint position limits"}),"\n",(0,i.jsx)(t.li,{children:"Joint velocity limits"}),"\n",(0,i.jsx)(t.li,{children:"Communication timeouts"}),"\n",(0,i.jsx)(t.li,{children:"Balance thresholds"}),"\n",(0,i.jsx)(t.li,{children:"Emergency stop functionality"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The safety layer should be able to:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Detect dangerous conditions"}),"\n",(0,i.jsx)(t.li,{children:"Issue emergency stops when necessary"}),"\n",(0,i.jsx)(t.li,{children:"Provide safe recovery procedures"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(t.p,{children:"This module has covered the fundamentals of ROS 2 for humanoid robot control. You now understand the core concepts, advanced communication patterns, humanoid-specific control techniques, available packages, and best practices for safety and performance. These foundations are essential for building robust humanoid robot systems."}),"\n",(0,i.jsx)(t.hr,{})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},8453(e,t,n){n.d(t,{R:()=>r,x:()=>a});var o=n(6540);const i={},s=o.createContext(i);function r(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);